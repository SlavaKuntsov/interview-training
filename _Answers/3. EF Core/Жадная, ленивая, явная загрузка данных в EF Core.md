 ## Жадная загрузка (Eager Loading)

**Определение:**  
Жадная загрузка — это стратегия, при которой связанные сущности загружаются одновременно с основной сущностью в одном запросе к базе данных.

**Синтаксис в EF Core:**

```csharp
// Загрузка заказов вместе с их строками заказа (OrderItems)
var orders = context.Orders
    .Include(o => o.OrderItems)
    .ThenInclude(oi => oi.Product)
    .ToList();
```

**Плюсы:**

- **Меньшее число запросов:** одиночный SQL-запрос с JOIN, что снижает накладные расходы на установление соединения.
    
- **Предсказуемость:** вы явно указываете, какие связи нужны, избегая неожиданных дополнительных запросов.
    
- **Снижение проблемы N+1:** предотвращает выполнение отдельного запроса для каждой связанной сущности.
    

**Минусы:**

- **Избыточные данные:** если вы указываете слишком много Include, в результат попадут ненужные столбцы и строки.
    
- **Сложные запросы:** глубокая вложенность `.ThenInclude()` может привести к громоздким и тяжёлым для оптимизатора SQL-запросам.
    
- **Ограничения SQL:** некоторые базы данных имеют ограничения на число JOIN-ов, что может привести к ошибкам.
    

**Когда использовать:**

- Когда заранее известно, какие связи нужны для отображения или обработки.
    
- При необходимости минимизировать количество обращений к базе данных.
    

---

## Ленивая загрузка (Lazy Loading)

**Определение:**  
Ленивая загрузка откладывает запрос на получение связанных сущностей до того момента, когда к этим сущностям впервые обращаются в коде.

**Настройка EF Core:**

1. Установить пакет `Microsoft.EntityFrameworkCore.Proxies`.
    
2. В `DbContext` включить прокси:
    
    ```csharp
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder
            .UseLazyLoadingProxies()
            .UseSqlServer(connectionString);
    }
    ```
    
3. Свойства навигации должны быть виртуальными:
    
    ```csharp
    public class Order
    {
        public int Id { get; set; }
        public virtual ICollection<OrderItem> OrderItems { get; set; }
    }
    ```
    

**Плюсы:**

- **Экономия памяти и времени:** загрузка связанных сущностей происходит только при необходимости.
    
- **Простота кода:** не нужно явно указывать `.Include()` во всех запросах.
    

**Минусы:**

- **Проблема N+1:** при итерировании коллекции может генерироваться много отдельных запросов.
    
- **Неочевидность поведения:** дополнительный запрос может выполняться в глубине кода, что усложняет отладку.
    
- **Накладные расходы на прокси:** прокси-классы чуть более тяжелые и могут влиять на производительность.
    

**Когда использовать:**

- Когда точные связи не известны заранее и большинство связанных данных не требуется.
    
- В небольших приложениях или при прототипировании, где нагрузка на БД невелика.
    

---

## Явная загрузка (Explicit Loading)

**Определение:**  
Явная загрузка — это стратегия, при которой разработчик в коде самостоятельно вызывает методы загрузки связанных сущностей после первоначального запроса.

**Синтаксис EF Core:**

```csharp
// Загрузка заказа без связей.
var order = context.Orders.Find(orderId);

// Явная загрузка коллекции OrderItems
context.Entry(order)
    .Collection(o => o.OrderItems)
    .Load();

// Явная загрузка единственной навигации (reference)
context.Entry(order)
    .Reference(o => o.Customer)
    .Load();
```

**Плюсы:**

- **Гибкость:** вы загружаете именно те связи, которые нужны, в нужный момент.
    
- **Контроль:** можно комбинировать с фильтрацией и сортировкой:
    
    ```csharp
    context.Entry(order)
        .Collection(o => o.OrderItems)
        .Query()
        .Where(oi => oi.Quantity > 0)
        .OrderByDescending(oi => oi.Quantity)
        .Load();
    ```
    
- **Избежание избыточной загрузки:** загрузка только после проверки условий.
    

**Минусы:**

- **Дополнительный код:** гораздо более многословный, чем `.Include()`.
    
- **Опасность забыть загрузить:** если забыть вызвать `.Load()`, последующее обращение к данным вернёт пустую коллекцию.
    
- **Несколько дополнительных запросов:** каждый `.Load()` генерирует отдельный SQL-запрос.
    

**Когда использовать:**

- Когда необходимо условно (функционально) загрузить связь на основе результата первоначального запроса.
    
- При работе с большими и сложными моделями, где заранее неизвестно, какие данные потребуются.
    

---

## Сравнительная таблица

|Стратегия|Запрос(ы)|Контроль загрузки|Простота кода|Риск N+1|
|---|---|---|---|---|
|Eager Loading|1 (JOIN)|Явно через Include|Высокая|Нет|
|Lazy Loading|N+1|Автоматически при доступе|Средняя|Да|
|Explicit Loading|1 + M (на связи)|Явно через Entry.Load()|Низкая|Нет (при правильном вызове)|

## Рекомендации по выбору

- **Eager Loading**: когда чётко известно, что данные нужны сразу, и приоритет — минимизация числа запросов.
    
- **Lazy Loading**: в прототипах или там, где сложно предугадать зависимости, но БД справляется с N+1 нагрузкой.
    
- **Explicit Loading**: при динамическом построении модели данных, когда загрузка связей зависит от бизнес-логики.
    

## Примечания

- Можно комбинировать стратегии: начать с Eager, а дополнительные/условные связи — через Explicit.
    
- Для обнаружения проблемы N+1 используйте логи SQL-запросов или профилировщики (EF Core Logging, MiniProfiler).
    
- При большой нагрузке на БД предпочтительнее Eager или Explicit Loading с продуманными запросами.