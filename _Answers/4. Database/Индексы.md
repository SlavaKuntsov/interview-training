### Что такое индекс
Индекс — это специальная структура данных, связанная с таблицей, которая ускоряет поиск и сортировку строк по определённым столбцам. По сути, индекс — это «отдельная таблица», содержащая значение ключа и указатель (RID, row‑id или физический адрес) на соответствующую запись основной таблицы.

---

### Зачем нужны индексы
- **Ускорение выборок**: замена полного сканирования таблицы (`Seq Scan`) на более быстрый поиск в индексах (`Index Seek`, `Index Scan`).  
- **Повышение производительности JOIN**: индексы на колонках, участвующих в `JOIN`, значительно снижают стоимость соединений.  
- **Оптимизация сортировок и группировок**: использование индексированных ключей для `ORDER BY`, `GROUP BY`.  
- **Обеспечение уникальности**: уникальные индексы (`UNIQUE`) гарантируют, что в столбце не будет дублирующихся значений.

---

### Основные типы индексов

#### B‑Tree (Balanced Tree)
- **Принцип работы**: сбалансированное дерево, где листовые узлы содержат пары «ключ–ссылка», упорядоченные по возрастанию.  
- **Характеристики**:
  - Поддержка диапазонных запросов (`BETWEEN`, `>=`, `<=`).  
  - Логарифмическая сложность поиска, вставки и удаления (O(log N)).  
  - Наиболее распространённый тип во всех ведущих СУБД.  
- **Пример создания**:

```sql
  CREATE INDEX idx_users_lastname
    ON users (last_name);
```
#### Hash‑Index


- **Принцип работы**: хеш‑таблица, где значения ключа преобразуются через хеш‑функцию в указатель на бакет.
    
- **Характеристики**:
    
    - Очень быстрые точечные поиски `=` (O(1) в среднем).
        
    - Не поддерживают диапазонные запросы.
        
    - Занимают чуть больше памяти из‑за хранения хеш‑таблицы.
        
- **Поддержка**: есть в PostgreSQL (`USING HASH`), ограничена в других СУБД.
    

#### Bitmap‑Index

- **Принцип работы**: для каждого возможного значения ключа хранится битовая карта строк, где 1 означает совпадение.
    
- **Характеристики**:
    
    - Отлично подходят для низкоразреженных колонок (с небольшим числом уникальных значений).
        
    - Эффективны при комбинировании через побитовые операции (AND, OR).
        
    - Чувствительны к частым обновлениям — накладные расходы на пересчёт карты.
        
- **Использование**: часто в аналитических хранилищах (data warehouse), OLAP.
    

#### Clustered vs Non‑Clustered

- **Clustered Index**
    
    - Физический порядок строк таблицы соответствует порядку ключей индекса.
        
    - Одна таблица может иметь только один кластерный индекс.
        
    - Быстрый диапазонный доступ, но дорого перестраивать при больших объёмах вставок/удалений.
        
- **Non‑Clustered Index**
    
    - Отдельная структура, содержащая ключ и указатель на строку.
        
    - Можно создавать несколько.
        
    - Обычно хранит только ключевые столбцы, а при необходимости — включает (INCLUDE) дополнительные колонки для покрытия запросов.
        

---

### Составные (Composite) и покрывающие (Covering) индексы

- **Составной индекс**
    
    - Построен по нескольким колонкам в определённом порядке.
        
    - Полезен для сложных фильтров и сортировок:
        
        ```sql
        CREATE INDEX idx_orders_date_amount
          ON orders (order_date DESC, total_amount);
        ```
        
    - Порядок колонок критичен: индекс эффективно используется только если в WHERE или ORDER BY присутствуют первые колонки.
        
- **Покрывающий индекс**
    
    - Включает не только ключи, но и другие колонки (`INCLUDE`) для полного покрытия запроса, чтобы избежать обратного обращения к таблице:
        
        ```sql
        CREATE INDEX idx_products_name_price
          ON products (name)
          INCLUDE (price, category_id);
        ```
        
    - Запрос типа `SELECT price, category_id FROM products WHERE name = 'X'` полностью обрабатывается из индекса.
        

---

### Стоимость и обслуживание индексов

- **Преимущества**
    
    - Снижение времени выполнения `SELECT`.
        
    - Уменьшение нагрузки на CPU и диск при поисках, сортировках и соединениях.
        
- **Недостатки**
    
    - **Дисковое пространство**: каждый индекс занимает дополнительное место.
        
    - **Замедление операций записи**: `INSERT`, `UPDATE`, `DELETE` должны поддерживать все связанные индексы.
        
    - **Фрагментация**: при частых изменениях отдельные страницы индекса могут стать неграничными, что требует **REORGANIZE** или **REBUILD**.
        
- **Поддержка актуальности статистики**
    
    - СУБД используют **statistics** для оценки кардинальности и селективности.
        
    - Регулярно запускайте `ANALYZE` (PostgreSQL) или `UPDATE STATISTICS` (SQL Server), чтобы планы оставались оптимальными.
        

---

### Практические рекомендации

- **Индексируйте колонки в WHERE, JOIN и ORDER BY** — это основные потребители ресурсов.
    
- **Избегайте избыточных индексов** — каждый добавленный индекс увеличивает overhead на запись.
    
- **Используйте покрывающие индексы** для самых «тяжёлых» отчётных запросов.
    
- **Следите за порядком колонок в составных индексах** — он определяет, насколько полно СУБД сможет использовать индекс.
    
- **Реорганизуйте и перестраивайте фрагментированные индексы** по расписанию, особенно в системах с высоким соотношением чтения/записи.
    
- **Тестируйте влияние на производительность** до и после добавления/удаления индексов, анализируя EXPLAIN-план и реальные метрики выполнения.
    
- **Не индексируйте слишком короткие или часто обновляемые столбцы** (например, булевы флаги или поля, в которые постоянно пишут), это приведёт к избыточным I/O.
    

---

Глубокое понимание типов индексов, их механизмов и компромиссов позволяет проектировать схемы баз данных с высокой производительностью и масштабируемостью, находя баланс между скоростью чтения и эффективностью записи.