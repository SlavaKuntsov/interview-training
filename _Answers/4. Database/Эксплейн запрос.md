### Что такое EXPLAIN
EXPLAIN — служебная команда SQL, позволяющая получить план выполнения произвольного запроса. План показывает, каким образом СУБД собирается читать и обрабатывать данные: какие индексы использовать, в каком порядке соединять таблицы, какие операции сортировки и агрегации применять.

---

### Зачем нужен EXPLAIN
- **Поиск узких мест**: выявить «тяжёлые» операции (полные сканы таблиц, сортировки, хэш‑джоины).  
- **Проверка использования индексов**: удостовериться, что СУБД задействует созданные индексы.  
- **Оптимизация запросов**: на основе плана переписать запрос или добавить нужные индексы.  
- **Мониторинг и аудит**: регулярно проверять ключевые запросы в продакшене.

---

### Общая структура плана

1. **Node Type** — тип операции (Seq Scan, Index Scan, Hash Join, Merge Join, Sort, Aggregate и т. д.).  
2. **Cost** — оценка стоимости выполнения (начальная и конечная), выражается в условных единицах.  
3. **Rows** — оценочное количество строк, возвращаемое этой операцией.  
4. **Width** — оценочный «ширина» строки в байтах.  
5. **Actual Time / Rows** (в `EXPLAIN ANALYZE`) — фактическое время и фактическое число строк.  
6. **Extra Info** — дополнительные сведения: фильтры (`Filter`), условия соединения (`Join Filter`), использование индексов (`Index Cond`), оценка повторного использования блоков памяти (`Buffers`) и т. д.

---

### Пример в PostgreSQL

```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT o.id, o.date, c.name
FROM orders o
JOIN customers c ON c.id = o.customer_id
WHERE o.date >= '2025-01-01'
ORDER BY o.date DESC
LIMIT 100;
````

**Объяснение полей**

- **Seq Scan on orders o** — последовательное сканирование всей таблицы orders.
    
- **Index Scan using customers_pkey on customers c** — поиск по первичному ключу в customers.
    
- **Filter: (o.date >= '2025-01-01')** — применение фильтра на стороне узла.
    
- **Sort** — сортировка 100 строк по дате.
    
- **Buffers** — статистика чтения блоков из shared_buffers или диска.
    

---

### Пример в MySQL

```sql
EXPLAIN FORMAT=JSON
SELECT *
FROM order_items oi
WHERE oi.product_id = 42
  AND oi.quantity > 5;
```

**Ключевые поля JSON**

- **table** — имя таблицы.
    
- **type** — степень покрытия (ALL, index, range, ref, eq_ref, const).
    
- **possible_keys** — доступные индексы.
    
- **key** — используемый индекс.
    
- **rows** — оценочное число строк, просматриваемых этим шагом.
    
- **filtered** — процент строк, прошедших фильтр.
    
- **Extra** — дополнительно: `Using where`, `Using index`, `Using filesort`.
    

---

### Пример в SQL Server

```sql
SET STATISTICS PROFILE ON;
GO
SELECT p.Name, SUM(oi.Quantity) AS TotalQty
FROM Products p
LEFT JOIN OrderItems oi ON oi.ProductId = p.Id
GROUP BY p.Name;
GO
SET STATISTICS PROFILE OFF;
```

- **Physical Operation** — физическая операция (Table Scan, Index Seek, Hash Match, Stream Aggregate).
    
- **Estimated Operator Cost** — оценочная стоимость.
    
- **Actual Rows** — фактическое число строк.
    
- **Warnings** — предупреждения (например, spilling to tempdb).
    

---

### Ключевые типы узлов

|Узел|Описание|
|---|---|
|**Seq Scan**|Полный обход таблицы.|
|**Index Scan**|Просмотр индекса без фильтрации по ключам (в MySQL — `index`).|
|**Index Seek**|Целенаправленный поиск по индексу (MySQL — `ref`, `eq_ref`).|
|**Hash Join**|Соединение двух потоков при помощи хэш-таблицы.|
|**Merge Join**|Соединение упорядоченных входов, требует предварительной сортировки.|
|**Nested Loop**|Вложенный цикл: для каждой строки из первого потока перебираются строки второго.|
|**Sort**|Сортировка строк (может быть дорогой операцией).|
|**Aggregate**|Группировка и агрегирование (Sum, Count, Avg и т. д.).|
|**Bitmap Index Scan / Bitmap Heap Scan**|Эффективны при комбинировании нескольких фильтров.|

---

### Как читать и оптимизировать план

1. **Найдите «дорогие» узлы**
    
    - В `EXPLAIN ANALYZE` смотрите `Actual Time` и процент от общего времени.
        
2. **Проверьте использование индексов**
    
    - Если видите Seq Scan там, где есть подходящий индекс, подумайте о создании или корректировке существующего.
        
3. **Оцените фильтрацию**
    
    - Поля с `Filter` или `WHERE` могут быть вынесены в индекс, чтобы использовать `Index Seek` вместо Seq Scan.
        
4. **Сократите сортировки**
    
    - Постройте составные индексы, включающие колонки сортировки, чтобы убрать узел Sort.
        
5. **Перепишите соединения**
    
    - Поменяйте порядок таблиц или условия JOIN; используйте hint’ы, если СУБД неправильно выбирает план.
        
6. **Используйте PARTITIONING**
    
    - Для больших таблиц разделите их по диапазону или хешу, чтобы принудительно ограничить объём сканирования.
        
7. **Профилируйте периодически**
    
    - Планы со временем меняются из‑за роста данных или обновления статистики — анализируйте критичные запросы раз в квартал.
        

---

### Полезные советы

- **ANALYZE / UPDATE STATISTICS**: держите статистику актуальной, иначе СУБД будет строить некорректные планы.
    
- **Просмотр реального плана**: в PgAdmin, MySQL Workbench, SQL Server Management Studio — визуальный representation упрощает понимание.
    
- **EXPLAIN BUFFERS / IO**: узнайте, сколько блоков читается из кеша и диска.
    
- **SET PROFILING / STATISTICS**: замеряйте фактическое время и ресурсы.
    
- **Используйте утилиты**: `pgBadger`, `pt-query-digest`, Query Store (SQL Server) для анализа долгих запросов.
    

---

Понимание EXPLAIN-планов и умение их интерпретировать — фундаментальный навык для любого бэкенд-разработчика или DBA, позволяющий добиваться максимальной производительности и эффективного использования ресурсов базы данных.