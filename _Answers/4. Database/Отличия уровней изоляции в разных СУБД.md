### Общие уровни изоляции (ANSI SQL)
- **READ UNCOMMITTED**  
  - Позволяет «грязное» чтение (dirty reads), non‑repeatable и phantom‑анномалии.  
- **READ COMMITTED**  
  - Запрещает dirty reads, но допускает non‑repeatable reads и phantom‑анномалии.  
- **REPEATABLE READ**  
  - Запрещает dirty и non‑repeatable reads, но позволяет phantom‑анномалии (в некоторых реализациях).  
- **SERIALIZABLE**  
  - Полная изоляция; запрещает все перечисленные аномалии.

---

## SQL Server

- **READ UNCOMMITTED**  
  - Использует «грязные» считывания без блокировок (`NOLOCK` hint).  
- **READ COMMITTED (по умолчанию)**  
  - Опирается на **блокировки**: на чтение ставится shared‑lock, потом снимается сразу после чтения.  
  - **Фантомы** и non‑repeatable reads возможны.  
- **REPEATABLE READ**  
  - Shared‑lock удерживается на весь транзакционный цикл при чтении строк.  
  - Запрещены dirty и non‑repeatable reads. **Phantom‑анномалии** возможны (новые строки могут появляться).  
- **SNAPSHOT**  
  - MVCC‑режим: каждая транзакция видит «снимок» данных на момент её начала.  
  - Запрещены dirty, non‑repeatable и phantom‑анномалии.  
  - Требует включения `ALLOW_SNAPSHOT_ISOLATION` и/или `READ_COMMITTED_SNAPSHOT`.  
- **SERIALIZABLE**  
  - Дополнительно к REPEATABLE READ ставит range‑локи (ключ‑диапазоны), блокирует вставку строк в диапазон, предотвращая фантомы.

```sql
-- Включение snapshot isolation
ALTER DATABASE MyDb  
SET ALLOW_SNAPSHOT_ISOLATION ON;  
ALTER DATABASE MyDb  
SET READ_COMMITTED_SNAPSHOT ON;
````

---

## PostgreSQL

- **READ UNCOMMITTED**
    
    - Эквивалентен **READ COMMITTED**; «грязные» чтения фактически невозможны благодаря MVCC.
        
- **READ COMMITTED (по умолчанию)**
    
    - Каждая команда внутри транзакции видит последние зафиксированные данные на момент её старта.
        
    - Dirty reads запрещены; возможны non‑repeatable и phantom‑анномалии.
        
- **REPEATABLE READ**
    
    - По сути MVCC‑снимок на момент старта транзакции:
        
        - Запрещены dirty и non‑repeatable reads.
            
        - Phantom‑анномалии **запрещены**, так как транзакция видит только те строки, которые существовали на старте.
            
- **SERIALIZABLE**
    
    - Расширенная версия REPEATABLE READ с дополнительными проверками, эмулирующая полную сериализацию (конфликты транзакций могут приводить к ошибкам `SerializationFailure`).
        
    - Более строгий, чем REPEATABLE READ, защищает от «фантомов» и других конфликтов.
        

```sql
-- Установка уровня изоляции
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
...
COMMIT;
```

---

## MySQL (InnoDB)

- **READ UNCOMMITTED**
    
    - Позволяет dirty reads; редко используется.
        
- **READ COMMITTED**
    
    - MVCC‑снимок для каждой чтения: снимает отдельный снимок на каждую SQL-команду.
        
    - Dirty reads запрещены; non‑repeatable и phantom‑анномалии возможны.
        
- **REPEATABLE READ (по умолчанию)**
    
    - MVCC‑снимок един для всей транзакции.
        
    - Запрещены dirty и non‑repeatable reads.
        
    - Phantom‑анномалии **запрещены** благодаря **Next‑Key Locking** (комбинация record + gap locks).
        
- **SERIALIZABLE**
    
    - Все `SELECT` автоматически преобразуются в `SELECT ... LOCK IN SHARE MODE`, дополняя gap locks;
        
    - Запрещает dirty, non‑repeatable и phantom‑анномалии, но значительно снижает конкуренцию.
        

```sql
-- Изменение уровня для сессии
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
...
COMMIT;
```

---

## Oracle

- **READ COMMITTED (по умолчанию)**
    
    - MVCC‑снимок на момент начала каждой SQL‑операции.
        
    - Dirty reads запрещены; non‑repeatable и phantom‑анномалии возможны.
        
- **SERIALIZABLE**
    
    - MVCC‑снимок на момент старта транзакции.
        
    - Запрещает dirty и non‑repeatable reads; **фантомы возможны**, но при попытке изменения записей может возникать ошибка `ORA-08177: can't serialize access for this transaction`.
        
- **READ ONLY**
    
    - Специальный режим для транзакций только на чтение: данные видятся в консистентном состоянии на момент старта транзакции (подобно SERIALIZABLE‐MVCC).
        
    - Нет блокировок на чтение, разрешена высокая конкуренция.
        

```sql
-- Запуск транзакции в режиме SERIALIZABLE
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
...
COMMIT;
```

---

## SQLite

- **READ UNCOMMITTED**
    
    - Позволяет dirty reads, но на практике работает как READ COMMITTED.
        
- **READ COMMITTED (по умолчанию)**
    
    - Одновременная транзакция видит только те коммиты, которые произошли до начала SQL‑операции.
        
    - Dirty reads запрещены; non‑repeatable и phantom‑анномалии возможны.
        
- **SERIALIZABLE**
    
    - Ведёт себя аналогично **REPEATABLE READ**: транзакция видит снимок на момент старта.
        
    - Dirty и non‑repeatable reads запрещены; phantom‑анномалии возможны при вставках (из‑за упрощённой блокировочной модели).
        

```sql
-- Открытие транзакции в режиме SERIALIZABLE
PRAGMA read_uncommitted = false;
BEGIN TRANSACTION;
...
COMMIT;
```

---

## Резюме

|СУБД|По умолчанию|READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE|Доп. режимы|
|---|---|---|---|---|---|---|
|SQL Server|READ COMMITTED|`NOLOCK`|shared‑locks, допускает фантомы|shared‑locks на всю транзакцию, фантомы|range‑locks, полностью исключает фантомы|SNAPSHOT (MVCC)|
|PostgreSQL|READ COMMITTED|эквивалент RC|MVCC — снимок на каждую команду|MVCC — снимок на транзакцию, нет фантомов|надстройка над RR с проверками конфликтов|—|
|MySQL/InnoDB|REPEATABLE READ|`READ UNCOMMITTED`|MVCC — снимок на команду, фантомы|MVCC + Next‑Key Locks, запрет фантомов|`LOCK IN SHARE MODE`, риск блокировок|—|
|Oracle|READ COMMITTED|позволяет, но не рекомендуется|MVCC — снимок на команду, фантомы|нет явного RR (SERIALIZABLE ≈ MVCC транзакция)|MVCC‐снимок транзакции, фантомы иногда error|READ ONLY|
|SQLite|READ COMMITTED|работает как RC|RC — снимок на команду, фантомы|как SERIALIZABLE — снимок на транзакцию|как RR, фантомы возможны|—|

Глубокое понимание того, как каждая СУБД реализует и интерпретирует уровни изоляции, позволяет выбирать оптимальные настройки для ваших транзакций, балансируя между производительностью и гарантиями консистентности.