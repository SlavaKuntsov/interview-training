### Общая архитектура  
RabbitMQ — брокер сообщений, реализующий протокол AMQP (Advanced Message Queuing Protocol) и поддерживающий дополнительные плагины (STOMP, MQTT, HTTP). Основная задача — организация надёжного обмена сообщениями между отправителями (producers) и получателями (consumers) с возможностью маршрутизации, отложенной доставки, подтверждения и гарантии доставки.

---

### Основные компоненты  

- **Broker (узел)**  
  Сервер RabbitMQ, отвечающий за приём, хранение и доставку сообщений. Несколько узлов могут объединяться в кластер для отказоустойчивости и масштабирования.

- **Exchange (обменник)**  
  Точка приёма сообщений от продюсеров. Exchange получает сообщение и по правилам маршрутизации отправляет его в одну или несколько очередей. Типы обменников:
  - **Direct** — точное соответствие ключа маршрутизации (routing key) имени очереди.  
  - **Topic** — шаблонное соответствие по ключу с поддержкой `*` (одно слово) и `#` (несколько слов).  
  - **Fanout** — рассылает копию сообщения во все привязанные очереди, игнорируя routing key.  
  - **Headers** — маршрутизация по совпадению HTTP-подобных заголовков (вместо routing key).

- **Queue (очередь)**  
  Хранилище сообщений до тех пор, пока потребители их не заберут. Сообщения внутри очереди упорядочены по времени поступления (FIFO). Очереди привязываются к обменникам с использованием binding key или заголовков.

- **Binding (привязка)**  
  Связь между exchange и queue, задающая правило маршрутизации. Например, `exchange.bind(queue, routingKey = "invoice.*")`.

- **Producer**  
  Приложение или компонент, отправляющий сообщения в exchange с заданным routing key и заголовками. Может выбирать подтверждения доставки на уровне брокера (publisher confirms).

- **Consumer**  
  Приложение или компонент, подписывающееся на очередь и обрабатывающее поступающие сообщения. Может потреблять синхронно (basic.get) или асинхронно (basic.consume).

---

### Жизненный цикл сообщения  

1. **Publish**  
   Producer отправляет сообщение в exchange:  
```

channel.basicPublish(exchangeName, routingKey, mandatoryFlag, properties, body)

```
2. **Routing**  
Exchange сопоставляет routingKey и/или заголовки сообщения binding’ам и помещает сообщение в соответствующие очереди.  
3. **Storage**  
Сообщение хранится в очереди до получения потребителем или до истечения TTL/до удаления по политике лимита.  
4. **Delivery**  
Broker доставляет сообщение consumer’у:  
- **Push-модель**: broker вызывает `basic.deliver` на канале consumer’а.  
- **Pull-модель**: consumer самостоятельно запрашивает `basic.get`.  
5. **Acknowledge**  
После успешной обработки consumer отправляет `basic.ack` или `basic.nack/reject` (с переотправкой в зависимости от флага `requeue`).  
6. **Removal**  
При положительном подтверждении (`ack`) сообщение удаляется из очереди. При отрицательном может быть отброшено или возвращено.

---

### Надёжность и гарантии доставки

- **Durable Queues & Persistent Messages**  
- Очереди можно создавать с флагом `durable=true`, а сообщения — с `deliveryMode=2` (persistent). Тогда при перезапуске брокера и узла данные сохранятся на диске.  
- **Publisher Confirms**  
- Асинхронное подтверждение приёма (and записи) сообщения broker’ом: producer получает уведомления о каждом успешно записанном сообщении или ошибках.  
- **Transactions (AMQP tx)**  
- Можно оборачивать несколько `basic.publish` и `basic.ack` в транзакцию (`txSelect`/`txCommit`/`txRollback`), но в нагрузочных системах лучше использовать confirms.  
- **Dead Letter Exchange (DLX)**  
- Перенаправление сообщений, которые были отвергнуты, не подтверждены или истекли по TTL, в специальный обменник для последующей обработки.  
- **Message TTL & Queue TTL**  
- `message-ttl` — время жизни сообщения в очереди.  
- `expires` — время жизни самой очереди при отсутствии потребителей.

---

### Кластеризация и отказоустойчивость

- **Cluster**  
- Несколько узлов объединяются в кластер, разделяют metadata (всех очередь и binding).  
- Очереди по умолчанию являются локальными (хасят на узле), но для репликации можно использовать плагины.

- **Mirrored Queues (Classic HA)**  
- Классический механизм зеркалирования — очередь создаётся с политикой HA, и все реплики хранят сообщения на каждом узле-копии. Leader принимает записи, followers синхронизируются.

- **Quorum Queues**  
- Современный вариант HA-очередей на основе Raft: устойчивее к split-brain, приоритет пишущей реплики и автоматический failover.

- **Federation & Shovel**  
- Federation plugin — асинхронная репликация сообщений между кластерами RabbitMQ.  
- Shovel plugin — постоянная подача (shoveling) сообщений из одной очереди/обменника в другой, даже между разными брокерами.

---

### Тюнинг производительности

- **Channel Pooling**  
- Переиспользуйте каналы (`IModel`), их создание дорого; лучше заводить пул каналов для многопоточных producers/consumers.  
- **Prefetch Count (QoS)**  
- `channel.basicQos(prefetchCount = N)` ограничивает число одновременно доставляемых сообщений consumer’у, помогает балансировке и предотвращает перегрузку.  
- **Batch Publishing**  
- Можно собирать несколько сообщений перед отправкой и запуском confirms, снижая количество сетевых RTT.  
- **TCP Настройки**  
- Увеличение `frame_max`, настройка `heartbeat` и `tcp_keepalive` для стабильности соединения.  
- **Конфигурация дискового хранения**  
- Использовать SSD, настраивать `vm_memory_high_watermark` и лимиты disk_free_limit.

---

### Безопасность

- **Аутентификация**  
- Встроенный механизм RabbitMQ (username/password), LDAP, OAuth 2.0 (через плагин).  
- **Авторизация**  
- Политики доступа по вируальному хосту (`vhost`), обменникам и очередям.  
- **Шифрование**  
- TLS для соединений клиентов, inter-node TLS для шифрования трафика между узлами кластера.  
- **Плагины безопасности**  
- Rate limiting plugin, firewall plugin, IP whitelist/blacklist.

---

### Мониторинг и управление

- **Management Plugin**  
- Веб-интерфейс и HTTP API для просмотра очередей, соединений, обменников, метрик throughput, задержек.  
- **Prometheus Exporter**  
- Собственные метрики RabbitMQ или через plugin rabbitmq_prometheus.  
- **Firehose & Tracing**  
- Firehose включается для захвата всех операций publish/deliver и передачи в specified exchange для аудитинга.

---

### Клиентские библиотеки и экосистема

- **.NET (RabbitMQ.Client)**  
- **Java (amqp-client)**  
- **Python (pika)**  
- **JavaScript (amqplib)**  
- **Go (streadway/amqp)**  
- **Spring AMQP, MassTransit, EasyNetQ** — обобщённые библиотеки для упрощённого взаимодействия и шаблонов

---

**RabbitMQ** — гибкая и надёжная платформа очередей, подходящая для множества сценариев: от простой очереди задач до реального времени событийных шинов и распределённых workflow. Глубокое понимание внутренних механизмов и возможностей позволяет выстраивать высокодоступные, производительные и безопасные архитектуры обмена сообщениями

---


![[Pasted image 20241207113330.png]]
 RabbitMQ состоит из нескольких основных компонентов: очередь (Queue), сообщение (Message), обменник (Exchange), биндинг (Binding), паблишер (Publisher), получатель (Consumer).

- **Очередь (Queue)** — это структура данных, где хранятся сообщения до того, как получатель их обработает. Очередь может быть временной или постоянной, в зависимости от потребностей приложения.
- **Сообщение (Message)** — это единица данных, которая передается от издателя к подписчику через очередь. Сообщения могут быть разных типов и форматов.
- **Обменник (Exchange)** — это компонент, который принимает сообщения от издателей и направляет их в соответствующие очереди.
- **Биндинг (Binding)** — это связь между обменником и очередью, которая определяет, какие сообщения в какую очередь будут направлены.
- **Продюсер (Producer)** — это приложение, которое публикует сообщения в обменник.
- **Получатель (Consumer)** — это приложение, которое получает сообщения из очереди и обрабатывает их.

**Работа RabbitMQ происходит следующим образом:**
- продюсер отправляет сообщение в обменник;
- обменник направляет сообщение в соответствующую очередь, в зависимости от типа обмена и биндинга;
- получатель подписывается на очередь и начинает получать сообщения из нее;
- получатель обрабатывает сообщения и выполняет необходимые действия;
- получатель подтверждает получение сообщения, чтобы исключить его из очереди;
- если сообщение не было подтверждено в течение определенного времени, оно будет повторно отправлено в очередь.