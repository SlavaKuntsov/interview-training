# Основные принципы REST API

REST (Representational State Transfer) — архитектурный стиль проектирования веб‑сервисов, предложенный Роем Филдингом. В его основе лежат шесть ключевых ограничений, применённых к веб‑ресурсам. Соблюдение этих принципов обеспечивает простоту, масштабируемость и гибкость API.

## 1. Клиент‑сервер (Client‑Server)

Разделение ответственности между клиентом и сервером:
- **Клиент** отвечает за пользовательский интерфейс и опыт взаимодействия.  
- **Сервер** управляет хранением данных и бизнес‑логикой.  
- Чёткое разделение упрощает развитие и масштабирование обеих частей независимо.

## 2. Отсутствие состояния (Stateless)

Каждый HTTP‑запрос от клиента к серверу должен содержать всю необходимую информацию для его обработки:
- Сервер не хранит контекста между запросами (сессии).  
- Все данные аутентификации, параметры и состояние передаются в заголовках, URI или теле запроса.  
- Плюсы: упрощённый горизонтальный масштаб, надёжность при сбоях.  
- Минусы: иногда требует дополнительной передачи токенов (JWT, API‑ключи).

## 3. Кэширование (Cacheable)

Ответы сервера должны явно указывать, можно ли их кэшировать:
- Заголовки `Cache-Control`, `Expires`, `ETag` позволяют клиентам и промежуточным прокси хранить ответы.  
- Правильное кэширование снижает нагрузку на сервер и ускоряет отклик.  
- Необходимо различать **cacheable** (GET‑запросы) и **non-cacheable** (POST/PUT/DELETE по умолчанию).

## 4. Единообразный интерфейс (Uniform Interface)

Упрощает и стандартизирует взаимодействие между компонентами. Состоит из четырёх подпринципов:

1. **Идентификация ресурсов**  
   - Ресурс — любая сущность (пользователь, заказ, товар).  
   - Идентифицируется уникальным URI, например `/api/users/123`.

2. **Манипулирование ресурсами через представления (Representations)**  
   - Клиент получает представление ресурса (JSON, XML, HAL).  
   - Для модификации отправляет новую репрезентацию (PUT, PATCH).

3. **Самоописывающие сообщения (Self‑descriptive Messages)**  
   - HTTP‑метод (`GET`, `POST`, `PUT`, `DELETE`) несёт семантику действия.  
   - Заголовки (`Content-Type`, `Accept`) определяют формат.  
   - В теле — данные (JSON‑объект) с понятными полями.

4. **Гипермедиа как двигатель состояния приложения (HATEOAS)**  
   - Ответы включают ссылки (`_links` или `links`) на доступные действия:  
     ```json
     {
       "id": 123,
       "name": "Alice",
       "_links": {
         "self": { "href": "/api/users/123" },
         "orders": { "href": "/api/users/123/orders" }
       }
     }
     ```
   - Клиент динамически узнаёт, какие операции доступны.

## 5. Слойность (Layered System)

Архитектура может состоять из нескольких слоёв (прокси, шлюзы, балансировщики), скрывая внутренние детали:
- Каждый слой не знает о существовании других, кроме своего непосредственного соседа.  
- Позволяет внедрять кэш‑прокси, брандмауэры, load balancers без изменения API.

## 6. Код по требованию (Code on Demand) — необязательно

Сервер может отправлять исполняемый код клиенту (JavaScript) для расширения функциональности:
- Пример: REST‑API возвращает скрипт для визуализации данных.  
- Используется редко и не всегда желателен (увеличивает сложность и снижает предсказуемость).

---

## Дополнительные рекомендации

- **Иерархия эндпоинтов**  
  Организуйте URI логично:  
  `/api/customers/{customerId}/orders/{orderId}/items`.

- **HTTP‑методы и семантика**  
  - `GET` — получение ресурса, не изменяет состояние.  
  - `POST` — создание нового ресурса.  
  - `PUT` — замена ресурса целиком.  
  - `PATCH` — частичное обновление.  
  - `DELETE` — удаление ресурса.

- **Коды статуса**  
  - `200 OK` — успешная обработка GET/PUT/PATCH.  
  - `201 Created` — успешное создание через POST (+ заголовок `Location`).  
  - `204 No Content` — успешный запрос без тела ответа (DELETE, PUT без возврата).  
  - `400 Bad Request` — некорректный запрос.  
  - `401 Unauthorized` — требуется аутентификация.  
  - `403 Forbidden` — недостаточно прав.  
  - `404 Not Found` — ресурс не найден.  
  - `409 Conflict` — конфликт состояния (например, дублирование).  
  - `500 Internal Server Error` — ошибка сервера.

- **Версионирование**  
  - Через URI: `/api/v1/users`.  
  - Через заголовки: `Accept: application/vnd.myapp.v1+json`.  
  - Обеспечивает обратную совместимость при эволюции API.

- **Документация**  
  - Используйте OpenAPI (Swagger): генерируйте спецификацию и UI для тестирования.  
  - Детализируйте модели запросов/ответов, коды ошибок и примеры.

- **Безопасность**  
  - Аутентификация: JWT, OAuth 2.0, API‑ключи.  
  - Шифрование: всегда отдавайте только по HTTPS.  
  - Ограничение скорости (rate limiting) и защита от DDoS.

- **Pagination, Filtering, Sorting**  
  - Для коллекций используйте параметры:  
    `?page=2&pageSize=50&sort=-createdAt&status=active`.  
  - В ответе возвращайте метаданные:  
    ```json
    {
      "items": [ … ],
      "totalCount": 120,
      "page": 2,
      "pageSize": 50
    }
    ```

---

REST API, построенный в соответствии с этими принципами, обладает высокой предсказуемостью, масштабируемостью и прозрачностью для разработчиков и систем.  
```