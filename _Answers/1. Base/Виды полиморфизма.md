## Определение

**Полиморфизм** (от греч. "множество форм") - это возможность объектов с одинаковым интерфейсом иметь разную внутреннюю структуру и поведение. Это один из основных принципов ООП, позволяющий писать более гибкий и расширяемый код.

## Виды полиморфизма

### 1. Ad-hoc полиморфизм (Полиморфизм перегрузки)

**Определение**: Возможность использования одного имени для разных операций в зависимости от типов операндов.

**Виды**:

- **Перегрузка методов** - методы с одинаковым именем, но разными параметрами
- **Перегрузка операторов** - разное поведение операторов для разных типов

```csharp
// Перегрузка методов
public class Calculator
{
    public int Add(int a, int b) => a + b;
    public double Add(double a, double b) => a + b;
    public string Add(string a, string b) => a + b;
}

// Перегрузка операторов
public class Vector
{
    public double X { get; set; }
    public double Y { get; set; }
    
    public static Vector operator +(Vector a, Vector b)
    {
        return new Vector { X = a.X + b.X, Y = a.Y + b.Y };
    }
}
```

### 2. Универсальный полиморфизм (Параметрический полиморфизм)

**Определение**: Возможность написания кода, который работает с разными типами данных без изменения структуры алгоритма.

**Реализация через дженерики**:

```csharp
// Параметрический полиморфизм
public class Repository<T> where T : class
{
    private readonly List<T> _items = new();
    
    public void Add(T item) => _items.Add(item);
    public T Get(int index) => _items[index];
    public IEnumerable<T> GetAll() => _items;
}

// Использование
var userRepo = new Repository<User>();
var productRepo = new Repository<Product>();
```

### 3. Полиморфизм подтипов (Полиморфизм включения)

**Определение**: Возможность использования объектов производных классов через интерфейс базового класса или интерфейса.

**Реализация через наследование и интерфейсы**:

```csharp
// Базовый класс
public abstract class Animal
{
    public abstract void MakeSound();
    public virtual void Move() => Console.WriteLine("Animal moves");
}

// Производные классы
public class Dog : Animal
{
    public override void MakeSound() => Console.WriteLine("Woof!");
    public override void Move() => Console.WriteLine("Dog runs");
}

public class Cat : Animal
{
    public override void MakeSound() => Console.WriteLine("Meow!");
    public override void Move() => Console.WriteLine("Cat walks");
}

// Использование полиморфизма
public class AnimalShelter
{
    public void MakeAllAnimalsSound(Animal[] animals)
    {
        foreach (Animal animal in animals)
        {
            animal.MakeSound(); // Полиморфный вызов
        }
    }
}
```

### 4. Полиморфизм принуждения (Coercion)

??? мб интерфейсный ???

%% **Определение**: Автоматическое преобразование одного типа в другой для выполнения операции.

```csharp
// Неявные преобразования
int intValue = 42;
double doubleValue = intValue; // Неявное преобразование

// Явные преобразования
double pi = 3.14159;
int truncatedPi = (int)pi; // Явное преобразование

// Пользовательские преобразования
public class Temperature
{
    public double Celsius { get; set; }
    
    public static implicit operator Temperature(double celsius)
    {
        return new Temperature { Celsius = celsius };
    }
    
    public static explicit operator double(Temperature temp)
    {
        return temp.Celsius;
    }
}
```
 %%
## Механизмы реализации полиморфизма в Csharp

### 1. Виртуальные методы и переопределение

```csharp
public class Shape
{
    public virtual double CalculateArea() => 0;
    public virtual void Draw() => Console.WriteLine("Drawing shape");
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public override double CalculateArea() => Width * Height;
    public override void Draw() => Console.WriteLine("Drawing rectangle");
}
```

### 2. Абстрактные классы и методы

```csharp
public abstract class DatabaseProvider
{
    public abstract void Connect();
    public abstract void ExecuteQuery(string query);
    
    public void Disconnect() // Конкретная реализация
    {
        Console.WriteLine("Disconnecting...");
    }
}

public class SqlServerProvider : DatabaseProvider
{
    public override void Connect() => Console.WriteLine("Connecting to SQL Server");
    public override void ExecuteQuery(string query) => Console.WriteLine($"Executing: {query}");
}
```

### 3. Интерфейсы

```csharp
public interface IPaymentProcessor
{
    void ProcessPayment(decimal amount);
    bool ValidatePayment(decimal amount);
}

public class CreditCardProcessor : IPaymentProcessor
{
    public void ProcessPayment(decimal amount) => Console.WriteLine($"Processing ${amount} via credit card");
    public bool ValidatePayment(decimal amount) => amount > 0 && amount <= 10000;
}

public class PayPalProcessor : IPaymentProcessor
{
    public void ProcessPayment(decimal amount) => Console.WriteLine($"Processing ${amount} via PayPal");
    public bool ValidatePayment(decimal amount) => amount > 0;
}
```

### 4. Делегаты и события

```csharp
public delegate void EventHandler<T>(T eventArgs);

public class EventPublisher
{
    public event EventHandler<string> OnMessage;
    
    public void PublishMessage(string message)
    {
        OnMessage?.Invoke(message); // Полиморфный вызов всех подписчиков
    }
}
```

## Преимущества полиморфизма

1. **Расширяемость**: Легко добавлять новые типы без изменения существующего кода
2. **Гибкость**: Один интерфейс для работы с разными типами
3. **Повторное использование**: Код может работать с семейством типов
4. **Инкапсуляция**: Скрытие деталей реализации за общим интерфейсом

## Недостатки

1. **Производительность**: Виртуальные вызовы медленнее прямых
2. **Сложность**: Может усложнить понимание кода
3. **Отладка**: Сложнее отследить, какой метод будет вызван

## Практические примеры использования

### Стратегия (Strategy Pattern)

```csharp
public interface ISortingStrategy
{
    void Sort<T>(T[] array) where T : IComparable<T>;
}

public class QuickSort : ISortingStrategy
{
    public void Sort<T>(T[] array) where T : IComparable<T>
    {
        // Реализация быстрой сортировки
    }
}

public class MergeSort : ISortingStrategy
{
    public void Sort<T>(T[] array) where T : IComparable<T>
    {
        // Реализация сортировки слиянием
    }
}

public class SortingContext
{
    private ISortingStrategy _strategy;
    
    public void SetStrategy(ISortingStrategy strategy) => _strategy = strategy;
    public void Sort<T>(T[] array) where T : IComparable<T> => _strategy.Sort(array);
}
```

### Фабрика (Factory Pattern)

```csharp
public abstract class Logger
{
    public abstract void Log(string message);
}

public class FileLogger : Logger
{
    public override void Log(string message) => File.AppendAllText("log.txt", message);
}

public class ConsoleLogger : Logger
{
    public override void Log(string message) => Console.WriteLine(message);
}

public static class LoggerFactory
{
    public static Logger CreateLogger(string type)
    {
        return type.ToLower() switch
        {
            "file" => new FileLogger(),
            "console" => new ConsoleLogger(),
            _ => throw new ArgumentException("Unknown logger type")
        };
    }
}
```

## Заключение

Полиморфизм является мощным инструментом в ООП, который позволяет создавать гибкий и расширяемый код. Понимание различных видов полиморфизма и их применения критически важно для создания качественных приложений на платформе .NET.


---

1. **Ad-hoc Полиморфизм** 
Также известный как перегрузка (overloading), ad-hoc полиморфизм позволяет создавать несколько методов с одинаковым именем, но с различными параметрами. Компилятор выбирает, какой метод вызвать, основываясь на переданных аргументах. 
2. **Параметрический Полиморфизм** 
Параметрический полиморфизм достигается с использованием обобщений (generics). Он позволяет писать методы и классы, которые могут работать с любым типом данных. 
3. **Подтиповый Полиморфизм** 
Также известный как наследование (inheritance) и переопределение (overriding), подтиповый полиморфизм позволяет объектам производных классов быть обработанными как объекты базового класса. Это ключевой элемент полиморфизма в ООП. 
4. **Интерфейсный Полиморфизм** 
Интерфейсный полиморфизм достигается за счет использования интерфейсов, что позволяет различным классам реализовать один и тот же набор методов.