## 1. API Gateway

**Описание:**  
– Единая точка входа во всю систему микросервисов.  
– Маршрутизация HTTP-запросов к нужному сервису, агрегация ответов, трансформация (преобразование) запросов/ответов, аутентификация/авторизация.

**Реализация в .NET:**  
- [Ocelot](https://github.com/ThreeMammals/Ocelot) — популярный .NET API Gateway.  
- Использование YARP (Yet Another Reverse Proxy) от Microsoft.

**Пример конфигурации Ocelot (ocelot.json):**  
```json
{
  "Routes": [
    {
      "DownstreamPathTemplate": "/orders/{everything}",
      "DownstreamScheme": "https",
      "DownstreamHostAndPorts": [ { "Host": "orderservice", "Port": 443 } ],
      "UpstreamPathTemplate": "/api/orders/{everything}",
      "UpstreamHttpMethod": [ "GET", "POST", "PUT", "DELETE" ]
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "https://gateway.mycompany.com"
  }
}
````

---

## 2. Service Discovery

**Описание:**  
– Автоматическое обнаружение адресов работающих экземпляров сервисов.  
– Избегает жёсткой привязки к IP/портам.

**Реализации:**

- **Client-side discovery**: клиенты обращаются к реестру (Consul, Eureka) и сами выбирают экземпляр.
    
- **Server-side discovery**: через API Gateway или load‑balancer (Traefik, Nginx).
    

**Консоль .NET – пример регистрации в Consul:**

```csharp
services.AddSingleton<IConsulClient>(sp =>
   new ConsulClient(cfg => cfg.Address = new Uri("http://localhost:8500")));

services.AddHostedService<ConsulRegistrationService>(); // регистрирует на старте
```

---

## 3. Circuit Breaker

**Описание:**  
Предотвращает постоянные вызовы к падающему или медленному сервису:

- **Closed**: запросы проходят.
    
- **Open**: запросы сразу отвергаются, возвращается fallback.
    
- **Half-Open**: после таймаута пропускаются пробные запросы.
    

**В .NET с Polly:**

```csharp
var breaker = Policy
    .Handle<HttpRequestException>()
    .CircuitBreakerAsync(
        exceptionsAllowedBeforeBreaking: 3,
        durationOfBreak: TimeSpan.FromSeconds(30),
        onBreak: (ex, ts) => { /* логировать */ },
        onReset: () => { /* шина событий */ });

await breaker.ExecuteAsync(() => httpClient.GetAsync("/api/data"));
```

---

## 4. Retry и Exponential Backoff

**Описание:**  
Повторные попытки выполнения операции при временных сбоях, с увеличивающейся задержкой между попытками.

**Полли‑конфигурация:**

```csharp
var retry = Policy
    .Handle<HttpRequestException>()
    .WaitAndRetryAsync(
        retryCount: 5,
        sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt)),
        onRetry: (ex, ts) => { /* логировать */ });
```

---

## 5. Bulkhead

**Описание:**  
Изоляция ресурсов между разными потоками или компонентами, чтобы сбой в одном не влиял на другие.  
– Применяется через пул отдельных потоков/соединений.

**Пример в Polly:**

```csharp
var bulkhead = Policy.BulkheadAsync(
    maxParallelization: 10,
    maxQueuingActions: 20,
    onRejected: context => Task.CompletedTask);
```

---

## 6. Circuit‑Bulkhead‑Retry — Комбинация

Часто комбинируют три паттерна:

1. Retry (пробуем снова)
    
2. Circuit Breaker (остановка при системной проблеме)
    
3. Bulkhead (изоляция ресурсов)
    

```csharp
var policyWrap = Policy.WrapAsync(bulkhead, breaker, retry);
await policyWrap.ExecuteAsync(() => DoRemoteCall());
```

---

## 7. Saga (Оркестрация и Хореография)

**Описание:**  
Управление распределённой транзакцией через серию локальных транзакций с компенсацией при неудаче.

- **Оркестрация**: центральный сервис контролирует последовательность шагов.
    
- **Хореография**: каждый сервис публикует события, дирижёра-внешнего нет.
    

**Инструменты .NET:**

- MassTransit (поддержка Saga State Machine)
    
- NServiceBus Sagas
    

---

## 8. Event Sourcing и CQRS

### 8.1. Event Sourcing

– Хранение последовательности событий вместо текущего состояния.  
– Позволяет воспроизвести любое состояние системы.

### 8.2. CQRS (Command Query Responsibility Segregation)

– Разделение команд (изменяющих состояние) и запросов (только читающих).  
– Оптимизация моделей чтения и записи отдельно.

**.NET-стек:**

- EventStoreDB
    
- Marten
    
- MediatR (для разделения команд/запросов)
    

---

## 9. API Composition / Aggregator Pattern

**Описание:**  
Агрегирование данных из нескольких микросервисов в единый ответ.

**Реализация:**

- Использование API Gateway с композитором ответов.
    
- Backend for Frontend (BFF) — отдельный сервис для каждого типа клиента (мобильный, веб).
    

---

## 10. Sidecar

**Описание:**  
Развёртывание вспомогательного контейнера рядом с основным сервисом.  
– Используется для мониторинга, логирования, прокси, сертификатов (например, Istio).

---

## 11. Idempotency Key

**Описание:**  
Гарантирует, что повторный запрос (например, из-за таймаута) не приведёт к дублированию эффекта.  
– Клиент передаёт уникальный идентификатор операции.  
– Сервис сохраняет успешные идентификаторы и, при получении дубликата, возвращает прежний ответ.

**Пример в ASP.NET Core:**

```csharp
[HttpPost]
public async Task<IActionResult> CreateOrder([FromHeader(Name="Idempotency-Key")] string idKey, OrderDto dto)
{
    if (_idempoStore.Exists(idKey))
        return _idempoStore.GetCachedResponse(idKey);

    var result = await _orderService.Create(dto);
    _idempoStore.Store(idKey, result);
    return Ok(result);
}
```

---

## 12. Health Check

**Описание:**  
Автоматизированная проверка доступности сервисов и зависимостей.

**.NET под ASP.NET Core:**

```csharp
services.AddHealthChecks()
    .AddSqlServer(connectionString)
    .AddCheck<CustomDependencyHealthCheck>("custom_dep");

app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health/ready", new HealthCheckOptions { /* ... */ });
    endpoints.MapHealthChecks("/health/live", new HealthCheckOptions { /* ... */ });
});
```

---

## 13. Monitoring & Distributed Tracing

- **OpenTelemetry**: сбор метрик, логов и трассировок.
    
- **Jaeger/Zipkin**: визуализация распределённых трассировок.
    
- **Prometheus + Grafana**: сбор и отображение метрик.
    

---

## 14. Безопасность и аутентификация

- **OAuth2 / OpenID Connect**: IdentityServer4 / Duende IdentityServer.
    
- **JWT**: проверка токенов в API Gateway и сервисах.
    
- **mTLS**: для межсервисных вызовов.
    

---

## 15. Управление конфигурацией

- **Centralized Configuration**: Azure App Configuration, Consul KV, etcd.
    
- **Feature Flags**: LaunchDarkly, [Microsoft.FeatureManagement](https://github.com/microsoft/feature-management-dotnet).
    

---

## Заключение

Эффективное применение паттернов микросервисной архитектуры в .NET помогает:

- Обеспечить надёжность и устойчивость к сбоям.
    
- Упростить развёртывание и масштабирование.
    
- Улучшить сопровождение и развиваемость системы.
    

Выбор конкретных инструментов и комбинация паттернов зависят от требований системы: объёма транзакций, SLA, готовности команды и её опыта. ```