### Подробное объяснение теории для повторения:

---

#### **1. Async/await**

##### Основы:

- **Async**: указывает, что метод является асинхронным и может использовать `await`.
- **Await**: используется для приостановки выполнения метода до завершения асинхронной операции.

##### Преимущества:

- Асинхронность позволяет не блокировать основной поток, что важно для UI-приложений и веб-серверов.
- Например, ожидание завершения HTTP-запроса или чтения файла.

##### Пример:

```csharp
public async Task<string> GetDataAsync()
{
    using HttpClient client = new HttpClient();
    string result = await client.GetStringAsync("https://example.com");
    return result;
}
```

##### Важные моменты:

- **Методы с async возвращают `Task` или `Task<T>`** (или `void` для событий).
- **Deadlock**: возможен, если вызывающий поток блокируется (например, `Task.Result` вместо `await`).
- **Exceptions**: Исключения из асинхронного кода нужно обрабатывать через `try/catch`.

---

#### **2. Parallel/Asynchronous/Multithreading Programming**

##### **Различия:**

1. **Multithreading**:
    
    - Работа с несколькими потоками.
    - Пример: запуск фоновой задачи с `Thread`.
    - Сложен для ручного управления (синхронизация данных, deadlocks).
2. **Parallel Programming**:
    
    - Выполнение задач параллельно, использует все ядра процессора.
    - Пример: `Parallel.For` для быстрого выполнения циклов.
    
    ```csharp
    Parallel.For(0, 100, i => { Console.WriteLine(i); });
    ```
    
3. **Asynchronous Programming**:
    
    - Основан на событиях и коллбеках, не использует поток до завершения операции.
    - Например, `async/await` для ожидания завершения задачи.

##### **Когда использовать?**

- **UI/веб-приложения**: Асинхронность важна для поддержки responsiveness.
- **Высоконагруженные вычисления**: Параллельное выполнение для повышения производительности.

---

#### **3. Types of Locking Mechanisms**

##### **Lock**

- Блокирует доступ к критической секции внутри одного процесса.
- Пример:
    
    ```csharp
    private readonly object _lockObject = new object();
    
    public void CriticalSection()
    {
        lock (_lockObject)
        {
            // Код, который нельзя выполнять одновременно
        }
    }
    ```
    
- **Минус**: Не работает между процессами.

##### **Mutex**

- Блокировка для синхронизации между процессами.
- Пример:
    
    ```csharp
    using var mutex = new Mutex(false, "GlobalMutex");
    if (mutex.WaitOne())
    {
        try { /* Код */ }
        finally { mutex.ReleaseMutex(); }
    }
    ```
    

##### **Semaphore**

- Ограничивает количество потоков, которым одновременно разрешен доступ к ресурсу.
- Пример:
    
    ```csharp
    SemaphoreSlim semaphore = new SemaphoreSlim(3); // Максимум 3 потока
    await semaphore.WaitAsync();
    try { /* Код */ }
    finally { semaphore.Release(); }
    ```
    

##### Сравнение:

| Механизм  | Уровень         | Одновременный доступ | Применение                     |
| --------- | --------------- | -------------------- | ------------------------------ |
| Lock      | Внутри процесса | 1 поток              | Простые задачи                 |
| Mutex     | Межпроцессный   | 1 поток              | Общие ресурсы между процессами |
| Semaphore | Межпроцессный   | Несколько потоков    | Ограничение доступа            |

---

#### **4. Dependency Injection (DI)**

##### Суть:

- DI — это способ предоставления зависимостей объекту извне, вместо их создания внутри класса.
- Упрощает тестирование и уменьшает связанность компонентов.

##### Пример:

1. Без DI:
    
    ```csharp
    public class OrderService
    {
        private readonly PaymentService _paymentService = new PaymentService();
        public void ProcessOrder() { _paymentService.Pay(); }
    }
    ```
    
2. С DI:
    
    ```csharp
    public class OrderService
    {
        private readonly IPaymentService _paymentService;
        public OrderService(IPaymentService paymentService) { _paymentService = paymentService; }
        public void ProcessOrder() { _paymentService.Pay(); }
    }
    ```
    

##### Использование в ASP.NET Core:

- В `Startup.cs`:
    
    ```csharp
    services.AddScoped<IPaymentService, PaymentService>();
    ```
    

---

#### **5. Garbage Collector (GC)**

##### Основы:

- Автоматически управляет памятью в .NET, удаляя объекты, которые больше не используются.
- Генерации:
    - **Gen 0**: короткоживущие объекты (например, локальные переменные).
    - **Gen 1**: промежуточные.
    - **Gen 2**: долгоживущие (статические данные, глобальные объекты).

##### Пример ручного запуска:

```csharp
GC.Collect();
```

##### Важные моменты:

- **Finalize**: вызывается перед удалением объекта.
- **Dispose**: используется для освобождения управляемых ресурсов вручную.

---

#### **6. Finalizer, IDisposable, Destructor, using**

##### **IDisposable и using**:

- Протокол освобождения ресурсов вручную.
- Пример:
    
    ```csharp
    using (var file = new FileStream("file.txt", FileMode.Open))
    {
        // Работа с файлом
    } // Dispose() вызывается автоматически
    ```
    

##### **Finalizer**:

- Автоматический метод очистки ресурсов.
- Пример:
    
    ```csharp
    ~MyClass() { /* Освобождение ресурсов */ }
    ```
    

##### Разница:

- `Dispose`: вручную вызов.
- `Finalize`: автоматический, когда объект становится недоступен.

---

#### **7. Const/Readonly**

##### **Const**:

- Задает неизменяемое значение, определяемое на этапе компиляции.
- Пример:
    
    ```csharp
    public const double Pi = 3.14159;
    ```
    

##### **Readonly**:

- Задает значение, которое может быть изменено только в конструкторе.
- Пример:
    
    ```csharp
    public readonly string Name;
    
    public MyClass(string name) { Name = name; }
    ```
    

##### Разница:

|**Const**|**Readonly**|
|---|---|
|Только для примитивных типов или `string`|Любые типы данных|
|Значение должно быть известно на этапе компиляции|Можно задать в рантайме|
|Статическое по умолчанию|Может быть экземплярным|

---

Эти темы составляют базовую теорию, необходимую для работы с .NET и C#. Важно не только изучить их, но и попробовать реализовать код, чтобы закрепить знания.