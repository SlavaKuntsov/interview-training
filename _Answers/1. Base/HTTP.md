### [1] Что такое HTTP

HTTP расшифровывается как **HyperText Transfer Protocol** - широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам). Протокол HTTP предполагает использование клиент-серверной структуры передачи данных. HTTP работает по классической модели клиент-сервер: клиент открывает соединение, чтобы сделать запрос, а затем ждет ответа от сервера.

**HTTP-запросы**

- Версия HTTP - версия используемого протокола HTTP;
- URL - идентификатор ресурса;
- HTTP-метод - метод, описывающий действие, которое должно быть выполнено;
- заголовки HTTP-запроса - список пар ключ-значение;
- HTTP body - необязательный контейнер данных, описываемый заголовками **Content-Type** и **Content-Length**.

**HTTP-ответы**

- Код состояния HTTP - описывает результат выполненного действия;
- Заголовки HTTP-ответа - те же, что и заголовки HTTP-запроса;
- HTTP body - необязательный контейнер данных ответа, также описывается заголовками **Content-Type** и **Content-Length**.

**Коды состояния HTTP**

Коды состояния HTTP-ответов указывают, был ли успешно выполнен конкретный HTTP-запрос. Ответы делятся на пять классов:

- **Информационные** ответы (100 - 199);
- **Успешные** ответы (200 - 299);
- **Переадресация** сообщений (300 - 399);
- **Ошибка клиента** ответы (400 - 499);
- **Ошибка сервера** ответы (500 - 599).

|_Подробнее:_|
|---|
|[Что такое HTTP](https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/)|
|[HTTP гайд](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)|
|[Коды состояния ответа](https://developer.mozilla.org/ru/docs/Web/HTTP/Status)|

  

### [2] HTTP Методы

> HTTP определяет набор методов запроса для указания желаемого действия, которое должно быть выполнено для данного ресурса. Каждый из них реализует свою семантику, но некоторые общие черты разделяются группой этих методов: например, метод запроса может быть **безопасным**, **идемпотентным** или **кешируемым**.

- HTTP-метод является **безопасным**, если он не изменяет состояние сервера. Другими словами, метод безопасен, если он приводит к операции только для чтения.
    
- HTTP-метод является **идемпотентным**, когда повторно при выполнении одного и того же запроса с теми же параметрами не изменяется состояние ресурса на сервере. Другими словами, идемпотентные запросы можно выполнять несколько раз, а результат будет как при однократном запросе. Идемпотентность обеспечивает надежность и предсказуемость взаимодействия между клиентами и серверами. Она гарантирует, что повторные запросы не вызовут неожиданных или нежелательных изменений на сервере;
    
- **кешируемый** ответ - это HTTP-ответ, который может быть кеширован, то есть сохранен, чтобы быть извлеченным и использованным позже, без нового запроса к серверу. Не все HTTP-ответы можно кешировать.
    

**GET**

HTTP-метод **GET** запрашивает представление указанного ресурса. **GET** - запросы должны только получать данные.

**HEAD**

HTTP-метод **HEAD** запрашивает заголовки, идентичные тем, что возвращаются, если указанный ресурс будет запрошен с помощью HTTP-метода **GET**. Такой запрос может быть выполнен перед загрузкой большого ресурса, например, для увеличения пропускной способности.

**POST**

HTTP-метод **POST** предназначен для отправки данных на сервер. Тип тела запроса указывается в заголовке [Content-Type](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Type).

**PUT**

HTTP-метод **PUT** создаёт новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса. Разница между **PUT** и **POST** в том, что **PUT** является идемпотентным, в случае с **POST**, множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.

**TRACE**

HTTP-метод **TRACE** выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.

Конечный получатель запроса должен отразить полученное сообщение, исключая некоторые поля описанные ниже, назад клиенту как тело сообщения с ответом 200 (OK) с заголовком [Content-Type](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Type) **message/http**. Конечный получатель это либо исходный сервер, либо первый сервер получивший значение **[Max-Forwards** (en-US)]([https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards)) в запросе.

**OPTIONS**

HTTP-метод **OPTIONS** используется для описания параметров соединения с целевым ресурсом. Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) чтобы указать весь сервер целиком.

**PATCH**

Метод запроса HTTP **PATCH** частично изменяет ресурс. **PATCH** может как быть идемпотентным, так и не быть, в отличие от **PUT**, который всегда идемпотентен. Операция считается идемпотентной, если её многократное выполнение приводит к тому же результату, что и однократное выполнение. Например, если автоинкрементное поле является важной частью ресурса, то **PUT** перезапишет его (т.к. он перезаписывает всё), но **PATCH** может и не перезаписать.

**DELETE**

Данный метод удаляет указанный ресурс.

**CONNECT**

Запускает двустороннюю связь с запрошенным ресурсом. Метод можно использовать для открытия туннеля. К примеру, метод CONNECT может использоваться для доступа к сайту, который использует SSL (en-US) (HTTPS).

|_Подробнее:_|
|---|
|[Методы HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods)|

  

### [3] HTTPS

HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы [SSL](https://ru.wikipedia.org/wiki/SSL) и [TLS](https://ru.wikipedia.org/wiki/TLS). Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от [снифферских](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80_%D1%82%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0) атак и атак типа [man-in-the-middle](https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA_%D0%BF%D0%BE%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5), при условии, что будут использоваться шифрующие средства и _сертификат сервера проверен и ему доверяют._

По умолчанию HTTPS URL использует 443 [TCP](https://ru.wikipedia.org/wiki/TCP)-[порт](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%82_\(TCP/IP\)) (для незащищённого HTTP — 80). Чтобы подготовить веб-сервер для обработки https-соединений, администратор должен получить и установить в систему сертификат открытого и закрытого ключа для этого веб-сервера. В TLS используется как [асимметричная схема шифрования](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%BC_%D0%BA%D0%BB%D1%8E%D1%87%D0%BE%D0%BC) (для выработки общего секретного ключа), так и [симметричная](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (для обмена данными, зашифрованными общим ключом). Сертификат открытого ключа подтверждает принадлежность данного открытого ключа владельцу сайта. Сертификат открытого ключа и сам открытый ключ посылаются клиенту при установлении соединения, закрытый ключ используется для расшифровки сообщений от клиента.

Существует возможность создать такой сертификат, не обращаясь в [центр сертификации](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8). Подписываются такие сертификаты этим же сертификатом и называются [самоподписанными](https://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BC%D0%BE%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82) (_self-signed_). Без проверки сертификата каким-то другим способом (например, звонок владельцу и проверка контрольной суммы сертификата) такое использование HTTPS подвержено [атаке посредника](https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%B0%D0%BA%D0%B0_%D0%BF%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0).

Эта система также может использоваться для аутентификации клиента, чтобы обеспечить доступ к серверу только [авторизованным пользователям](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C). Для этого администратор обычно создаёт сертификаты для каждого пользователя и загружает их в браузер каждого пользователя. Также будут приниматься все сертификаты, подписанные организациями, которым доверяет сервер. Такой сертификат обычно содержит имя и адрес электронной почты авторизованного пользователя, которые проверяются при каждом соединении, чтобы проверить личность пользователя без ввода пароля.

|_Подробнее:_|
|---|
|[HTTPS](https://hostiq.ua/wiki/http-https/)|

  

### [4] Что такое TLS и SSL

**Secure Sockets Layer (SSL)** — это протокол связи или набор правил, который создает безопасное соединение между двумя устройствами или приложениями в сети. Прежде чем делиться данными через Интернет, важно установить доверие и аутентифицировать другую сторону. **SSL** — это технология, которая использовалась для создания безопасного зашифрованного канала связи в любой сети. Однако **SSL** — это старая технология, которая содержит некоторые недостатки с точки зрения безопасности. Протокол **TLS** (Transport Layer Security) — это обновленная версия **SSL**, устраняющая существующие уязвимости **SSL**. **TLS** аутентифицируется более эффективно и продолжает поддерживать зашифрованные каналы связи.

И **SSL**, и **TLS** – это протоколы передачи данных, которые шифруют данные между серверами, приложениями, пользователями и системами. Они аутентифицируют обе стороны, соединенные по сети, чтобы те могли безопасно обмениваться данными.

Тахер Эльгамал руководил разработкой **SSL** и опубликовал **SSL 2.0** в 1995 году. Целью **SSL** было обеспечение безопасной передачи данных во всемирной паутине. После нескольких усовершенствований SSL Тим Диркс и Кристофер Аллен создали **TLS 1.0** в 1999 году как преемника **SSL 3.0**.

|_Подробнее:_|
|---|
|[TLS/SSL](https://www.ssl.com/faqs/faq-what-is-ssl/)|

  

### [5] Эволюция HTTP

**HTTP/0.9**

[Тим Бернерс-Ли](https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%BD%D0%B5%D1%80%D1%81-%D0%9B%D0%B8,_%D0%A2%D0%B8%D0%BC) английский учёный, один из создателей Всемирной паутины, разработал HTTP протокол в 1989 году. Спецификация протокола была опубликована в 1991 году под названием **HTTP/0.9**, и всё, что он умел на тот момент времени — возвращать веб-страницу с единственным методом GET.

```
GET /page.html
```

Протокол имел всего четыре термина:  **Соединение** (connection), **Разъединение** (disconnection), **Запрос** (request) и **Ответ** (response). Не было ни заголовков, ни статусов ответа и множества других инструментов, которые используются сейчас. Протокол работал поверх **TCP**, и соединение разрывалось сразу же после отправки ответа.

**HTTP/1.0**

В 1996 году вышла спецификация протокола **HTTP/1.0**. Протокол поддерживал уже несколько методов запроса: **GET**, **HEAD** и **POST**. Появились новые термины: _user agent_, _[proxy](https://blog.skillfactory.ru/glossary/proksi/)_, _gateway_, _cache_, _resource_, _client_, _server_.

**Отличия HTTP/1.0 от HTTP/0.9**

- Каждый запрос теперь сопровождается **версией протокола**;
- Ответ начинается с **кода статуса ответа**;
- Запрос и Ответ теперь сопровождаются Заголовками — **HTTP Headers**;
- Возможность передачи метаданных в заголовках, делает протокол гибким и расширяемым;
- Определение Content-Type в заголовках позволяет передавать документы, отличные от HTML файлов.

Однако, HTTP/1.0 не является официальным стандартом.

**HTTP/1.1**

Первая стандартизованная версия протокола HTTP — **HTTP/1.1** была опубликована в начале 1997 года, спустя несколько месяцев после появления HTTP/1.0. HTTP/1.1 на момент публикации поддерживал 7 методов:  GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE. Однако позднее, в 2010 году, в стандарт был добавлен метод PATCH, а в 2014 — CONNECT.

**Отличия HTTP/1.1 от HTTP/1.0**

- Поддержка виртуальных хостов, позволяющих серверам обслуживать несколько доменов на одном IP адресе;
- Поддержка постоянных соединений, позволяющих браузерам делать несколько запросов в рамках одного TCP соединения;
- Поддержка кеширования для экономии трафика и увеличения скорости;
- Пересылка данных частями (chunked), когда не известен размер итоговой страницы;
- Согласования, такие как: язык, кодировка или тип данных, позволяющих клиенту и серверу договориться об особенностях требуемого ответа.

Протокол HTTP/1.1 оказался очень удачным и стабильно прослужил в изначальной редакции более 15 лет. В процессе использования появилось только расширение протокола **HTTPS**, обеспечивающее шифрованную передачу данных между браузером и сервером используя механизмы **SSL/TLS**.

**HTTP/2**

HTTP/2 нацелен на более эффективное использование сетевых ресурсов и уменьшение видимых задержек. Это привело к созданию нового бинарного слоя формата данных, не имеющего обратной совместимости с HTTP/1.x серверами и клиентами.

Первый черновик HTTP/2 был построен на основе спецификации SPDY, а спецификация была опубликована в 2015 году. Важными аспектами стали параллелизация, приоритизация и управление потоками передачи данных:

- Под потоком понимается двунаправленная передача информации внутри установленного TCP соединения;
- Добавилась возможность мультиплексирования, когда несколько параллельных запросов могут использовать одно соединение;
- Добавилась приоритезация передаваемых данных;
- Серверу самостоятельно может инициировать передачу данных;
- Вместо текстовых данных, протокол использует бинарный формат передачи данных, что позволяет увеличить производительность и безопасность;
- Заголовки запросов и ответов сжимаются принудительно.

**HTTP/3**

С появлением смартфонов и множества других портативных устройств с беспроводной связью, общее количество веб трафика серьезно увеличилось. HTTP/2, работающий через TCP со своей проблемой **[head-of-line blocking](https://habr.com/ru/companies/selectel/articles/532868/)**, мог создавать задержки в запросах и ответах. Так как TCP обеспечивает строгую очерёдность передачи пакетов, то проблема с одним медленным пакетом может замедлять или вовсе ломать поток целиком. Также HTTP/2 не имел строгого требования к шифрованию данных, и по прежнему оставались проблемы с безопасностью при перехвате заголовков запросов и ответов.

HTTP/3 проектируется для решения этих проблем, и сейчас проходит тестирование с опубликованной спецификацией. Новый протокол должен решать текущие проблемы скорости, надёжности и безопасности для широкого сектора устройств.

- Вместо TCP, HTTP/3 строится на основе нового протокола **QUIC**, разрабатываемого в Google с 2012 года. QUIC работает через протокол **UDP** (User Datagram Protocol);
- QUIC сам обеспечивает мультиплексирование, и потеря одного пакета повлияет только на имеющий к этому пакету поток, другие потоки в рамках соединения продолжат свою работу;
- Заголовки запросов и ответов сжимаются **QPACK** вместо HPACK в HTTP/2;
- Для шифрования используется TLS 1.3 эффективно использующийся в HTTPS.

Последние версии браузеров Chrome, Firefox, Edge, Opera и некоторые мобильные браузеры уже поддерживают работу по HTTP/3, но для работы должна быть и поддержка со стороны сервера.

|_Подробнее:_|
|---|
|[Отличие HTTP версий](https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference)|

  

### [6] Cookie

Куки – это небольшие строки данных, которые хранятся непосредственно в браузере.

Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок [Set-Cookie](https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Set-Cookie). Куки обычно запоминаются браузером и посылаются в HTTP-заголовке [**Cookie** (en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.

**Настройки куки:**

- **path=/**, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже;
- **domain=site.com**, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах;
- **expires** или **max-age** устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера;
- **secure** делает куки доступным только при использовании HTTPS;
- **samesite** запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.

#### Для чего используются:

- Управления сеансом (логины, корзины для виртуальных покупок);
- Персонализации (пользовательские предпочтения);
- Трекинга (отслеживания поведения пользователей).

До недавнего времени куки использовались в качестве хранилища информации на стороне пользователя. Это могло иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API для хранения данных, это уже не так. Из-за того что куки пересылаются с каждым запросом, они могут ухудшать производительность (особенно при использовании мобильных сетей). В качестве хранилищ данных на стороне пользователя вместо них можно использовать [Web storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API) (**localStorage** и **sessionStorage**) и [IndexedDB](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API).

#### **Типы куки и время жизни**

1. **Сессионные куки:** сессионные или временные куки могут существовать только в тот промежуток времени, когда пользователь находится на сайте. После того, как он закрыл окно браузера, куки удаляются;
2. **Постоянные куки:** они удаляются либо через определенный промежуток времени, либо когда пользователь сам очистит куки. Таким образом, браузер передает их на сервер при каждом посещении сайта;
3. **Защищенные куки:** этот тип куки передают только через шифрованное соединение HTTPS;
4. **HTTPOnly куки:** к этому типу куки нельзя обратиться через API. Это предотвращает кражу куки.

#### Чтение из document.cookie

Значение **document.cookie** состоит из пар **ключ=значение**, разделённых **;**. Каждая пара представляет собой отдельное куки.

Чтобы найти определённое куки, достаточно разбить строку из **document.cookie** по **;**, и затем найти нужный ключ. Для этого можно использовать как регулярные выражения, так и функции для обработки массивов.

#### Размерность

Спецификации указывают минимальные объёмы, которые должны предоставляться браузерами для хранения cookie. Так, браузер должен хранить по меньшей мере 300 cookie по **4096 байт** каждая, и по меньшей мере 20 cookie для одного сервера или домена.

|_Подробнее:_|
|---|
|[Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)|
|[Куки, document.cookie](https://learn.javascript.ru/cookie)|