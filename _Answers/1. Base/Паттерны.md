## Оглавление
1. [Что такое паттерн проектирования](#1-что-такое-паттерн-проектирования)  
2. [Категории паттернов (GoF)](#2-категории-паттернов-gof)  
   - [Порождающие (Creational)](#21-порождающие-creational)  
   - [Структурные (Structural)](#22-структурные-structural)  
   - [Поведенческие (Behavioral)](#23-поведенческие-behavioral)  
3. [Порождающие паттерны](#3-порождающие-паттерны)  
   - [Singleton](#31-singleton)  
   - [Factory Method](#32-factory-method)  
   - [Abstract Factory](#33-abstract-factory)  
   - [Builder](#34-builder)  
   - [Prototype](#35-prototype)  
4. [Структурные паттерны](#4-структурные-паттерны)  
   - [Adapter](#41-adapter)  
   - [Decorator](#42-decorator)  
   - [Facade](#43-facade)  
   - [Composite](#44-composite)  
   - [Proxy](#45-proxy)  
5. [Поведенческие паттерны](#5-поведенческие-паттерны)  
   - [Observer](#51-observer)  
   - [Strategy](#52-strategy)  
   - [Command](#53-command)  
   - [Chain of Responsibility](#54-chain-of-responsibility)  
   - [State](#55-state)  
6. [Принципы SOLID и их связь с паттернами](#6-принципы-solid-и-их-связь-с-паттернами)  
7. [Когда и как применять паттерны](#7-когда-и-как-применять-паттерны)  
8. [Рекомендуемая литература и ресурсы](#8-рекомендуемая-литература-и-ресурсы)

---

## 1. Что такое паттерн проектирования

**Паттерн проектирования** — это проверенное временем, документированное решение типовой задачи проектирования программного обеспечения.  
Он описывает:
- Контекст применения (когда возникает проблема).
- Силуэты задействованных объектов и их взаимодействие.
- Последствия применения (затраты, плюсы и минусы).

**Цели паттернов**:
- Повышение повторного использования.
- Улучшение читаемости и сопровождаемости.
- Обеспечение гибкости при расширении и изменении требований.

---

## 2. Категории паттернов (GoF)

Книга «Design Patterns: Elements of Reusable Object‑Oriented Software» делит основные паттерны на три группы:

### 2.1. Порождающие (Creational)  
Отвечают за создание объектов, скрывая логику инстанцирования и повышая гибкость и повторное использование.

### 2.2. Структурные (Structural)  
Определяют, как объединять классы и объекты в более крупные структуры, упрощая систему и скрывая сложность.

### 2.3. Поведенческие (Behavioral)  
Описывают взаимодействие и распределение обязанностей между объектами, управляя потоками данных и управления.

---

## 3. Порождающие паттерны

### 3.1. Singleton

#### Описание  
Гарантирует существование только одного экземпляра класса и предоставляет глобальную точку доступа.

#### Применимость  
- Конфигурационные объекты  
- Логгеры  
- Пулы соединений

#### Реализация в C#
```csharp
public sealed class Logger
{
    private static readonly Lazy<Logger> _instance =
        new Lazy<Logger>(() => new Logger());
    public static Logger Instance => _instance.Value;
    private Logger() { /* инициализация */ }
    public void Log(string message) { /* запись */ }
}
````

#### Плюсы и минусы

- - Гарантирован единый экземпляр
        
- – Сложности с тестированием (решается через интерфейс и DI)
    

---

### 3.2. Factory Method

#### Описание

Определяет интерфейс для создания объекта, но оставляет подклассам решение, какой класс инстанцировать.

#### Сценарии

- Плагин‑архитектура
    
- Семейства схожих продуктов
    

#### Пример

```csharp
public interface IProduct { void Operate(); }

public abstract class Creator
{
    public abstract IProduct CreateProduct();
}

public class ConcreteCreatorA : Creator
{
    public override IProduct CreateProduct() => new ProductA();
}

public class ProductA : IProduct
{
    public void Operate() { /* ... */ }
}
```

---

### 3.3. Abstract Factory

#### Описание

Позволяет создавать семейства взаимосвязанных объектов, не специфицируя их конкретные классы.

#### Структура

- Абстрактная фабрика (интерфейс создания продуктов)
    
- Конкретные фабрики
    
- Абстрактные продукты и конкретные реализации
    

---

### 3.4. Builder

#### Описание

Отделяет конструирование сложного объекта от его представления, позволяя строить поэтапно.

#### Использование

- Построение сложных документов (HTML, XML)
    
- Конфигурируемые объекты (шифрование, HTTP‑запрос)
    

---

### 3.5. Prototype

#### Описание

Создаёт новые объекты путём клонирования («прототипирования») существующих экземпляров.

#### Применение

- Система, где создание новых объектов дорого
    
- Мемоизация состояния
    

---

## 4. Структурные паттерны

### 4.1. Adapter

#### Описание

Приспосабливает интерфейс одного класса к интерфейсу, ожидаемому клиентом.

#### Пример

```csharp
// Целевой интерфейс
public interface ITarget { void Request(); }

// Адаптируемый класс
public class Adaptee { public void SpecificRequest() { /* ... */ } }

// Адаптер
public class Adapter : ITarget
{
    private readonly Adaptee _adaptee;
    public Adapter(Adaptee adaptee) => _adaptee = adaptee;
    public void Request() => _adaptee.SpecificRequest();
}
```

---

### 4.2. Decorator

#### Описание

Динамически расширяет функциональность объекта, оборачивая его «в декоратор».

---

### 4.3. Facade

#### Описание

Предоставляет упрощённый интерфейс к сложной системе классов или подсистеме.

---

### 4.4. Composite

#### Описание

Структурирует объекты в древовидные иерархии «часть‑целое», позволяя обрабатывать элементы и группы единообразно.

---

### 4.5. Proxy

#### Описание

Предоставляет суррогат или заместитель другого объекта для контроля доступа.

---

## 5. Поведенческие паттерны

### 5.1. Observer

#### Описание

Определяет зависимость «один-ко-многим»: при изменении состояния объекта все подписчики уведомляются.

---

### 5.2. Strategy

#### Описание

Инкапсулирует семейство алгоритмов и делает их взаимозаменяемыми.

---

### 5.3. Command

#### Описание

Инкапсулирует запрос как объект, что позволяет параметризовать клиентов разными запросами, ставить их в очередь, логировать, отменять.

---

### 5.4. Chain of Responsibility

#### Описание

Передаёт запрос по цепочке обработчиков до тех пор, пока кто‑то не сможет его обработать.

---

### 5.5. State

#### Описание

Позволяет объекту менять поведение при смене его внутреннего состояния.

---

## 6. Принципы SOLID и их связь с паттернами

- **S**ingle Responsibility
    
- **O**pen–Closed
    
- **L**iskov Substitution
    
- **I**nterface Segregation
    
- **D**ependency Inversion
    

Паттерны помогают воплотить SOLID:

- Factory Method и DI — для DIP.
    
- Strategy и State — для OCP и LSP.
    
- Adapter — для ISP и DIP.
    

---

## 7. Когда и как применять паттерны

1. **Чётко определите проблему**: избегайте «паттерн‑хантинга».
    
2. **Оцените компромиссы**: сложность vs гибкость.
    
3. **Документируйте**: схема классов и поток выполнения.
    
4. **Тестируйте**: юнит‑тесты на каждый вариант поведения.
    

---

## 8. Рекомендуемая литература и ресурсы

- “Design Patterns: Elements of Reusable Object‑Oriented Software” (Erich Gamma et al.)
    
- “Head First Design Patterns” (Eric Freeman & Elisabeth Robson)
    
- Microsoft Docs: [Design patterns in .NET](https://docs.microsoft.com/dotnet/standard/design-patterns)
    

```

> **Основание ответа**: обобщённая теория паттернов проектирования, опыт работы с .NET и документация Microsoft.
```