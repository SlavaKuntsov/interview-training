
**Паттерн проектирования** — это проверенное временем, документированное решение типовой задачи проектирования программного обеспечения.  
Он описывает:
- Контекст применения (когда возникает проблема).
- Силуэты задействованных объектов и их взаимодействие.
- Последствия применения (затраты, плюсы и минусы).


### Порождающие
Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
### Структурные
Отвечают за построение удобных в поддержке иерархий классов.
### Поведенческие
Решают задачи эффективного и безопасного взаимодействия между объектами программы.


---
# Порождающие
## Singleton (Одиночка)

### Назначение  
Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к нему.

### Участники  
- **Singleton** — класс с приватным конструктором, статическим полем-экземпляром и статическим методом/свойством доступа.

### Пример на C#  
```csharp
public sealed class Logger
{
    private static readonly Lazy<Logger> _instance = new(() => new Logger());
    public static Logger Instance => _instance.Value;
    private Logger() { }
    public void Log(string message) => Console.WriteLine($"[{DateTime.Now}] {message}");
}
// Использование
Logger.Instance.Log("Application started");
````

---

## Factory Method (Фабричный метод)

### Назначение

Определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать.

### Участники

- **Creator** — абстрактный класс с фабричным методом `CreateProduct()`.
    
- **ConcreteCreator** — конкретные подклассы, реализующие фабричный метод.
    
- **Product** — абстракция создаваемых объектов.
    
- **ConcreteProduct** — конкретные продукты.
    

### Пример

```csharp
public abstract class Document
{
    public abstract void Print();
}
public class PDFDocument : Document { public override void Print() => Console.WriteLine("Print PDF"); }
public class WordDocument : Document { public override void Print() => Console.WriteLine("Print Word"); }

public abstract class Application
{
    public void Export() { var doc = CreateDocument(); doc.Print(); }
    protected abstract Document CreateDocument();
}
public class PDFApplication : Application
{
    protected override Document CreateDocument() => new PDFDocument();
}
public class WordApplication : Application
{
    protected override Document CreateDocument() => new WordDocument();
}
```

---

## Abstract Factory (Абстрактная фабрика)

### Назначение

Предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

### Участники

- **AbstractFactory** — методы создания каждого из продуктов.
    
- **ConcreteFactory** — конкретные фабрики.
    
- **AbstractProductA/B** — семейства продуктов.
    
- **ConcreteProductA1/B1, A2/B2** — конкретные продукты.
    

### Пример

```csharp
public interface IGUIFactory
{
    IButton CreateButton();
    ICheckbox CreateCheckbox();
}
public class WinFactory : IGUIFactory
{
    public IButton CreateButton() => new WinButton();
    public ICheckbox CreateCheckbox() => new WinCheckbox();
}
public class MacFactory : IGUIFactory
{
    public IButton CreateButton() => new MacButton();
    public ICheckbox CreateCheckbox() => new MacCheckbox();
}
```

---

## Builder (Строитель)

### Назначение

Отделяет конструирование сложного объекта от его представления, позволяя создавать разные представления.

### Участники

- **Builder** — интерфейс для создания частей продукта.
    
- **ConcreteBuilder** — конкретные строители.
    
- **Director** — знает порядок вызова шагов строителя.
    
- **Product** — итоговый сложный объект.
    

### Пример

```csharp
public class Pizza
{
    public string Dough; public string Sauce; public string Topping;
    public override string ToString() => $"{Dough}, {Sauce}, {Topping}";
}
public interface IPizzaBuilder
{
    void BuildDough(); void BuildSauce(); void BuildTopping();
    Pizza GetPizza();
}
public class HawaiianPizzaBuilder : IPizzaBuilder
{
    private Pizza _pizza = new();
    public void BuildDough() => _pizza.Dough = "cross"; 
    public void BuildSauce() => _pizza.Sauce = "mild"; 
    public void BuildTopping() => _pizza.Topping = "ham+pineapple";
    public Pizza GetPizza() => _pizza;
}
public class Director
{
    public void Construct(IPizzaBuilder builder)
    {
        builder.BuildDough();
        builder.BuildSauce();
        builder.BuildTopping();
    }
}
// Использование
var director = new Director();
var builder = new HawaiianPizzaBuilder();
director.Construct(builder);
Console.WriteLine(builder.GetPizza());
```

---

## Prototype (Прототип)

### Назначение

Создает новые объекты копированием (клонированием) уже существующих.

### Участники

- **Prototype** — определяет интерфейс `Clone()`.
    
- **ConcretePrototype** — конкретные реализации, реализующие клонирование.
    

### Пример

```csharp
public class Document : ICloneable
{
    public string Title; public List<string> Pages = new();
    public object Clone()
    {
        var clone = (Document)MemberwiseClone();
        clone.Pages = new List<string>(Pages);
        return clone;
    }
}
// Использование
var original = new Document { Title = "Report", Pages = { "Page1", "Page2" } };
var copy = (Document)original.Clone();
```

---
# Структурные
## Adapter (Адаптер)

### Назначение

Позволяет объектам с несовместимыми интерфейсами работать вместе.

### Участники

- **Target** — ожидаемый клиентом интерфейс.
    
- **Adapter** — реализует Target и содержит адаптируемый объект (Adaptee).
    
- **Adaptee** — существующий класс с несовместимым интерфейсом.
    

### Пример

```csharp
public interface ITarget { void Request(); }
public class Adaptee { public void SpecificRequest() => Console.WriteLine("Adaptee"); }
public class Adapter : ITarget
{
    private readonly Adaptee _adaptee = new();
    public void Request() => _adaptee.SpecificRequest();
}
```

---

## Bridge (Мост)

### Назначение

Разделяет абстракцию и реализацию так, чтобы их можно было изменять независимо.

### Участники

- **Abstraction** — содержит ссылку на Implementor.
    
- **RefinedAbstraction** — расширение Abstraction.
    
- **Implementor** — интерфейс реализации.
    
- **ConcreteImplementorA/B** — конкретные реализации.
    

### Пример

```csharp
public interface IRenderer { void RenderCircle(float x, float y, float radius); }
public class VectorRenderer : IRenderer
{
    public void RenderCircle(float x, float y, float radius) =>
        Console.WriteLine($"Drawing vector circle at {x},{y} radius {radius}");
}
public abstract class Shape
{
    protected IRenderer renderer;
    protected Shape(IRenderer renderer) => this.renderer = renderer;
    public abstract void Draw();
}
public class Circle : Shape
{
    private float x, y, r;
    public Circle(IRenderer renderer, float x, float y, float r)
        : base(renderer) { this.x = x; this.y = y; r = this.r = r; }
    public override void Draw() => renderer.RenderCircle(x, y, r);
}
// Использование
var circle = new Circle(new VectorRenderer(), 5, 5, 10);
circle.Draw();
```

---

## Composite (Компоновщик)

### Назначение

Позволяет сгруппировать объекты в древовидные структуры и работать с ними единообразно.

### Участники

- **Component** — общий интерфейс (содержит операцию и методы управления дочерними элементами).
    
- **Leaf** — примитивные элементы без потомков.
    
- **Composite** — узлы, содержащие дочерние компоненты.
    

### Пример

```csharp
public interface IGraphic
{
    void Draw(); void Add(IGraphic g); void Remove(IGraphic g);
}
public class Dot : IGraphic
{
    public void Draw() => Console.WriteLine("Dot");
    public void Add(IGraphic g) => throw new NotSupportedException();
    public void Remove(IGraphic g) => throw new NotSupportedException();
}
public class CompositeGraphic : IGraphic
{
    private readonly List<IGraphic> _children = new();
    public void Draw() { foreach (var c in _children) c.Draw(); }
    public void Add(IGraphic g) => _children.Add(g);
    public void Remove(IGraphic g) => _children.Remove(g);
}
// Использование
var root = new CompositeGraphic();
root.Add(new Dot());
var branch = new CompositeGraphic();
branch.Add(new Dot());
root.Add(branch);
root.Draw();
```

---

## Decorator (Декоратор)

### Назначение

Динамически добавляет объектам новую функциональность, обёртывая их.

### Участники

- **Component** — интерфейс или абстрактный класс.
    
- **ConcreteComponent** — исходный объект.
    
- **Decorator** — содержит ссылку на Component и реализует его интерфейс.
    
- **ConcreteDecorator** — расширяет Decorator, добавляя поведение.
    

### Пример

```csharp
public interface IMessage { string GetContent(); }
public class SimpleMessage : IMessage { public string GetContent() => "Hello"; }
public abstract class MessageDecorator : IMessage
{
    protected IMessage _message;
    protected MessageDecorator(IMessage msg) => _message = msg;
    public virtual string GetContent() => _message.GetContent();
}
public class HtmlEncodedMessage : MessageDecorator
{
    public HtmlEncodedMessage(IMessage msg) : base(msg) { }
    public override string GetContent() =>
        WebUtility.HtmlEncode(base.GetContent());
}
// Использование
IMessage msg = new HtmlEncodedMessage(new SimpleMessage());
Console.WriteLine(msg.GetContent());
```

---

## Facade (Фасад)

### Назначение

Предоставляет упрощённый интерфейс к сложной подсистеме.

### Участники

- **Facade** — оборачивает подсистемы и предоставляет простой метод.
    
- **Subsystem** — множество классов со сложным API.
    

### Пример

```csharp
public class Engine { public void Start() => Console.WriteLine("Engine on"); }
public class Lights { public void TurnOn() => Console.WriteLine("Lights on"); }
public class CarFacade
{
    private Engine _engine = new();
    private Lights _lights = new();
    public void Drive() { _lights.TurnOn(); _engine.Start(); }
}
// Использование
var car = new CarFacade();
car.Drive();
```

---

## Flyweight (Приспособленец)

### Назначение

Использует разделение для эффективной поддержки множества мелких объектов с одинаковыми данными.

### Участники

- **Flyweight** — интерфейс внутреннего состояния.
    
- **ConcreteFlyweight** — хранит разделяемое состояние.
    
- **FlyweightFactory** — обеспечивает кэширование и выдачу приспособленцев.
    
- **Client** — передаёт внешний (контекстный) состояние.
    

### Пример

```csharp
public class CharacterFlyweight
{
    private readonly char _symbol;
    public CharacterFlyweight(char symbol) => _symbol = symbol;
    public void Draw(int fontSize, string color) =>
        Console.WriteLine($"Draw {_symbol} size {fontSize} color {color}");
}
public class FlyweightFactory
{
    private readonly Dictionary<char, CharacterFlyweight> _pool = new();
    public CharacterFlyweight Get(char c)
    {
        if (!_pool.ContainsKey(c)) _pool[c] = new CharacterFlyweight(c);
        return _pool[c];
    }
}
// Использование
var factory = new FlyweightFactory();
var a1 = factory.Get('A');
var a2 = factory.Get('A');
a1.Draw(12, "red");
a2.Draw(14, "blue");
```

---

## Proxy (Заместитель)

### Назначение

Контролирует доступ к другому объекту, добавляя дополнительные действия (логирование, кеширование, безопасность).

### Участники

- **Subject** — общий интерфейс.
    
- **RealSubject** — реальный объект.
    
- **Proxy** — реализует Subject и хранит ссылку на RealSubject.
    

### Пример

```csharp
public interface IImage { void Display(); }
public class RealImage : IImage
{
    private string _file;
    public RealImage(string file) => _file = file;
    public void Display() => Console.WriteLine($"Displaying {_file}");
}
public class ImageProxy : IImage
{
    private string _file; private RealImage _real;
    public ImageProxy(string file) => _file = file;
    public void Display()
    {
        if (_real == null) _real = new RealImage(_file);
        Console.WriteLine("Logging: display image");
        _real.Display();
    }
}
// Использование
IImage img = new ImageProxy("photo.png");
img.Display();
```

---
# Поведенческие
## Chain of Responsibility (Цепочка обязанностей)

### Назначение

Передаёт запрос последовательно по цепочке обработчиков, пока один из них не обработает запрос.

### Участники

- **Handler** — интерфейс или абстрактный класс с полем следующего обработчика и методом `Handle()`.
    
- **ConcreteHandler** — конкретные обработчики, решающие запрос или передающие дальше.
    

### Пример

```csharp
public abstract class Logger
{
    protected Logger Next;
    public void SetNext(Logger next) => Next = next;
    public abstract void Log(string message, LogLevel level);
}
public class ConsoleLogger : Logger
{
    public override void Log(string msg, LogLevel lvl)
    {
        if (lvl == LogLevel.Info) Console.WriteLine($"Info: {msg}");
        else Next?.Log(msg, lvl);
    }
}
public class FileLogger : Logger
{
    public override void Log(string msg, LogLevel lvl)
    {
        if (lvl == LogLevel.Error) File.AppendAllText("log.txt", msg + "\n");
        else Next?.Log(msg, lvl);
    }
}
```

---

## Command (Команда)

### Назначение

Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов, ставить запросы в очередь, поддерживать отмену и логирование.

### Участники

- **Command** — интерфейс с методом `Execute()`.
    
- **ConcreteCommand** — хранит ссылку на Receiver и параметры, реализует `Execute()`.
    
- **Invoker** — вызывает команду.
    
- **Receiver** — знает, как выполнять действия.
    

### Пример

```csharp
public interface ICommand { void Execute(); }
public class Light
{
    public void On() => Console.WriteLine("Light On");
    public void Off() => Console.WriteLine("Light Off");
}
public class TurnOnCommand : ICommand
{
    private readonly Light _light;
    public TurnOnCommand(Light light) => _light = light;
    public void Execute() => _light.On();
}
public class RemoteControl
{
    public ICommand Command { get; set; }
    public void PressButton() => Command.Execute();
}
// Использование
var light = new Light();
var cmd = new TurnOnCommand(light);
var remote = new RemoteControl { Command = cmd };
remote.PressButton();
```

---

## Interpreter (Интерпретатор)

### Назначение

Определяет представление грамматики языка и интерпретатор предложений на этом языке.

### Участники

- **AbstractExpression** — общий интерфейс `Interpret(Context)`.
    
- **TerminalExpression / NonterminalExpression** — реализации для терминальных и нетерминальных символов.
    
- **Context** — содержит входные данные и вспомогательные структуры.
    

### Пример

```csharp
public class Context { public string Input; public int Output; }
public interface IExpression { void Interpret(Context ctx); }
public class NumberExpression : IExpression
{
    private int _number;
    public NumberExpression(int number) => _number = number;
    public void Interpret(Context ctx) => ctx.Output = _number;
}
public class AddExpression : IExpression
{
    private IExpression _left, _right;
    public AddExpression(IExpression left, IExpression right)
    {
        _left = left; _right = right;
    }
    public void Interpret(Context ctx)
    {
        _left.Interpret(ctx);
        int leftVal = ctx.Output;
        _right.Interpret(ctx);
        ctx.Output += leftVal;
    }
}
// Использование
var context = new Context();
var expr = new AddExpression(new NumberExpression(5), new NumberExpression(3));
expr.Interpret(context);
Console.WriteLine(context.Output); // 8
```

---

## Iterator (Итератор)

### Назначение

Предоставляет последовательный доступ к элементам коллекции без раскрытия её внутреннего представления.

### Участники

- **Aggregate** — интерфейс коллекции с методом `CreateIterator()`.
    
- **ConcreteAggregate** — конкретная коллекция.
    
- **Iterator** — интерфейс с `MoveNext()`, `Current`, `Reset()`.
    
- **ConcreteIterator** — реализует перебор.
    

### Пример

```csharp
public interface IIterator<T>
{
    bool MoveNext(); T Current { get; } void Reset();
}
public interface IAggregate<T> { IIterator<T> CreateIterator(); }
public class NumberAggregate : IAggregate<int>
{
    private int[] _numbers;
    public NumberAggregate(int[] nums) => _numbers = nums;
    public IIterator<int> CreateIterator() => new NumberIterator(this);
    public int[] Numbers => _numbers;
}
public class NumberIterator : IIterator<int>
{
    private NumberAggregate _aggregate; private int _index;
    public NumberIterator(NumberAggregate agg) { _aggregate = agg; _index = -1; }
    public bool MoveNext() => ++_index < _aggregate.Numbers.Length;
    public int Current => _aggregate.Numbers[_index];
    public void Reset() => _index = -1;
}
// Использование
var agg = new NumberAggregate(new[] {1,2,3});
var it = agg.CreateIterator();
while (it.MoveNext()) Console.WriteLine(it.Current);
```

---

## Mediator (Посредник)

### Назначение

Скрывает сложные взаимодействия между объектами, централизуя их через объект–посредник.

### Участники

- **Mediator** — интерфейс для общения компонентов.
    
- **ConcreteMediator** — реализует взаимодействие.
    
- **Colleague** — компоненты, общающиеся через посредника.
    

### Пример

```csharp
public interface IMediator { void Notify(object sender, string ev); }
public class ConcreteMediator : IMediator
{
    public ComponentA A { get; set; }
    public ComponentB B { get; set; }
    public void Notify(object sender, string ev)
    {
        if (ev == "A") B.DoB();
        if (ev == "B") A.DoA();
    }
}
public class ComponentA
{
    private IMediator _mediator;
    public ComponentA(IMediator m) => _mediator = m;
    public void DoA() => Console.WriteLine("A does something");
    public void Trigger() => _mediator.Notify(this, "A");
}
public class ComponentB { /* аналогично */ }
```

---

## Memento (Снимок)

### Назначение

Позволяет сохранять и восстанавливать внутреннее состояние объекта без нарушения инкапсуляции.

### Участники

- **Originator** — создаёт снимок и восстанавливает состояние из снимка.
    
- **Memento** — хранит состояние.
    
- **Caretaker** — сохраняет и управляет множеством снимков.
    

### Пример

```csharp
public class Memento
{
    public string State { get; }
    public Memento(string state) => State = state;
}
public class Originator
{
    public string State { get; set; }
    public Memento Save() => new(State);
    public void Restore(Memento m) => State = m.State;
}
// Использование
var origin = new Originator { State = "State1" };
var m1 = origin.Save();
origin.State = "State2";
origin.Restore(m1);
Console.WriteLine(origin.State); // State1
```

---

## Observer (Наблюдатель)

### Назначение

Определяет зависимость «один ко многим», при изменении состояния субъекта все наблюдатели получают уведомление.

### Участники

- **Subject** — хранит список наблюдателей, методы `Attach()`, `Detach()`, `Notify()`.
    
- **Observer** — интерфейс с методом `Update()`.
    
- **ConcreteSubject** / **ConcreteObserver** — конкретные реализации.
    

### Пример

```csharp
public interface IObserver { void Update(string state); }
public class Subject
{
    private readonly List<IObserver> _observers = new();
    private string _state;
    public string State
    {
        get => _state;
        set { _state = value; Notify(); }
    }
    public void Attach(IObserver o) => _observers.Add(o);
    public void Detach(IObserver o) => _observers.Remove(o);
    private void Notify() { foreach (var o in _observers) o.Update(_state); }
}
public class ConcreteObserver : IObserver
{
    private string _name;
    public ConcreteObserver(string name) => _name = name;
    public void Update(string state) => Console.WriteLine($"{_name} notified: {state}");
}
```

---

## State (Состояние)

### Назначение

Позволяет объекту менять поведение при изменении внутреннего состояния, делегируя работу соответствующему объекту-состоянию.

### Участники

- **Context** — содержит текущее состояние.
    
- **State** — интерфейс с методами, зависящими от состояния.
    
- **ConcreteStateA/B** — реализации различных состояний.
    

### Пример

```csharp
public interface IState { void Handle(Context ctx); }
public class Context
{
    public IState State { get; set; }
    public void Request() => State.Handle(this);
}
public class ConcreteStateA : IState
{
    public void Handle(Context ctx)
    {
        Console.WriteLine("State A handling; switching to B");
        ctx.State = new ConcreteStateB();
    }
}
public class ConcreteStateB : IState
{
    public void Handle(Context ctx)
    {
        Console.WriteLine("State B handling; switching to A");
        ctx.State = new ConcreteStateA();
    }
}
```

---

## Strategy (Стратегия)

### Назначение

Определяет семейство алгоритмов, инкапсулирует каждый и делает их взаимозаменяемыми.

### Участники

- **Strategy** — интерфейс алгоритма.
    
- **ConcreteStrategyA/B** — реализации.
    
- **Context** — использует Strategy.
    

### Пример

```csharp
public interface ISortStrategy { void Sort(int[] data); }
public class BubbleSort : ISortStrategy { /* ... */ }
public class QuickSort : ISortStrategy { /* ... */ }
public class Sorter
{
    private ISortStrategy _strategy;
    public Sorter(ISortStrategy strat) => _strategy = strat;
    public void Sort(int[] data) => _strategy.Sort(data);
}
// Использование
var sorter = new Sorter(new QuickSort());
sorter.Sort(array);
```

---

## Template Method (Шаблонный метод)

### Назначение

Определяет скелет алгоритма в методе, оставляя некоторые шаги подклассам.

### Участники

- **AbstractClass** — содержит `TemplateMethod()` с фиксированным порядком вызова шагов, некоторые из которых абстрактны или виртуальны.
    
- **ConcreteClass** — реализуют конкретные шаги.
    

### Пример

```csharp
public abstract class DataProcessor
{
    public void Process()
    {
        ReadData();
        TransformData();
        SaveData();
    }
    protected abstract void ReadData();
    protected abstract void TransformData();
    protected virtual void SaveData() => Console.WriteLine("Saving to default location");
}
public class CsvProcessor : DataProcessor
{
    protected override void ReadData() => Console.WriteLine("Read CSV");
    protected override void TransformData() => Console.WriteLine("Transform CSV");
}
```

---

## Visitor (Посетитель)

### Назначение

Позволяет добавлять операции над элементами объектов-структуры, не изменяя их классы.

### Участники

- **Visitor** — интерфейс с методами `VisitConcreteElementA/B()`.
    
- **ConcreteVisitor** — реализация операции.
    
- **Element** — интерфейс с методом `Accept(Visitor)`.
    
- **ConcreteElementA/B** — конкретные элементы.
    

### Пример

```csharp
public interface IVisitor
{
    void Visit(Book book);
    void Visit(Fruit fruit);
}
public interface IElement { void Accept(IVisitor visitor); }
public class Book : IElement
{
    public string Title; public void Accept(IVisitor v) => v.Visit(this);
}
public class ShoppingVisitor : IVisitor
{
    public void Visit(Book b) => Console.WriteLine($"Book: {b.Title}");
    public void Visit(Fruit f) => Console.WriteLine($"Fruit: {f.Name}");
}
```

---

Это полный обзор 23 шаблонов проектирования GoF: от создания объектов до архитектурных и поведенческих шаблонов. Каждый паттерн предоставляет отработанные решения общих задач, повышая гибкость, читаемость и расширяемость кода.