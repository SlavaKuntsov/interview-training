## Основная идея

Clean Architecture направлена на разделение приложения на независимые слои, где бизнес‑логика не зависит от внешних механизмов (базы данных, UI, фреймворки). Каждый слой взаимодействует с соседним через чётко определённые интерфейсы.

## Слои архитектуры

1. **Entities (Сущности)**
    
    - Представляют фундаментальные бизнес‑объекты и правила.
        
    - Это POCO-классы, не зависящие от фреймворков.
        
2. **Use Cases / Interactors (Сценарии использования)**
    
    - Инкапсулируют конкретные бизнес‑правила приложения.
        
    - Определяют входные и выходные модели (DTO), интерфейсы репозиториев.
        
    - Не зависят от UI, БД или внешних API.
        
3. **Interface Adapters (Адаптеры интерфейсов)**
    
    - Преобразуют данные из формата, удобного внутренним слоям, в формат внешних.
        
    - Содержат контроллеры ASP.NET, presenters, gateways, mappers.
        
4. **Frameworks & Drivers (Внешние детали)**
    
    - Конкретные реализации: БД (Entity Framework Core), веб‑сервер (Kestrel), UI (Razor, Blazor), внешние API.
        
    - Сюда попадают проекты Infrastructure, WebAPI, UI.
        

## Правило зависимостей

- Зависимости могут указывать только внутрь: внешние слои ссылаются на внутренние.
    
- Интерфейсы определяются в слоях Use Cases или Entities, реализации — во внешних.
    

## Пример структуры проекта

```
Solution
│
├─ Core
│   ├─ Entities
│   └─ UseCases
│       ├─ Interfaces
│       └─ Implementations
│
├─ Infrastructure
│   ├─ Persistence
│   │   └─ EFCore
│   └─ Services
│
└─ WebApi
    ├─ Controllers
    ├─ DTO
    └─ Startup.cs
```

## Поток данных

1. **WebApi** получает HTTP‑запрос, вызывает контроллер.
    
2. Контроллер мапит DTO в InputModel и вызывает Interactor.
    
3. **Use Case** выполняет бизнес‑логику, используя интерфейс репозитория.
    
4. Репозиторий (реализация в Infrastructure) работает с БД через EF Core.
    
5. Результат возвращается вверх, адаптеры мапят в DTO, контроллер формирует HTTP‑ответ.
    

## Преимущества

- **Независимость от фреймворков**: миграция с EF Core на другой ORM минимальна.
    
- **Тестируемость**: легко мокать интерфейсы Use Cases и репозиториев.
    
- **Поддерживаемость**: чёткое разделение ответственности.
    
- **Гибкость**: можно менять UI без затрагивания бизнес‑логики.
    

## Реализация в .NET

- Определите проекты по слоям: Core, Infrastructure, WebApi.
    
- В Core пропишите только сущности и интерфейсы.
    
- В Infrastructure добавьте EF Core; реализуйте репозитории и сервисы.
    
- В WebApi через `Startup.ConfigureServices` зарегистрируйте:
    
    ```csharp
    services.AddScoped<IOrderRepository, OrderRepository>();
    services.AddScoped<CreateOrderUseCase>();
    ```
    
- Используйте `MediatR` для маршрутизации запросов к Use Cases (опционально).
    

## Советы и анти‑паттерны

- **Не помещайте** бизнес‑правила в контроллеры или модели БД.
    
- **Избегайте** зависимости Core от Infrastructure.
    
- **Внимательно** следите за границами слоёв и интерфейсов.
    

---

_Основывается на практике применения Clean Architecture в .NET, руководствах Роберта Мартина и официальной документации Microsoft._



---
### Пример слоев чистой архитектры:

1. **Слой данных (Infrastructure Layer)**: Управляет взаимодействием с базой данных, внешними сервисами и средствами аутентификации.
2. **Слой приложений (Application Layer)**: Включает бизнес-логику, службы и обработку токенов.
3. **Слой домена (Domain Layer)**: Содержит основные сущности и правила бизнес-логики.
4. **Слой интерфейсов (Presentation Layer)**: Обеспечивает взаимодействие с клиентом, в данном случае React.

---

![[Pasted image 20241113104516.png]]

![[Clean-Architecture-1.png]]
### Layers

1. API
2. Application
3. Domain
4. Infrastructure
5. Persistence