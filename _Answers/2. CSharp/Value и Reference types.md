В .NET типы разделяются на две категории: значимые (`value`) и ссылочные (`reference`). Понимание различий между ними критически важно для управления памятью, производительности и предсказуемого поведения приложений.

## Область хранения и семантика копирования

- **Value types** (структуры `struct`, примитивы `int`, `bool`, `double`, `enum`) хранятся **непосредственно** там, где объявлены:
  - В локальных переменных и параметрах методов — на стеке (Stack).
  - В полях других объектов — внутри их области на куче (Heap).
- **Reference types** (классы `class`, интерфейсы `interface`, делегаты, `string`) хранят в куче (Heap) **экземпляр объекта**, а в переменной или поле хранится **ссылка** (указатель) на этот объект.

При присваивании:
- Значимого типа копируется **само значение** (по байтам).
- Ссылочного — копируется **ссылка**; оба указателя начинают указывать на один и тот же объект.

```csharp
struct Point { public int X, Y; }
class Order { public int Id; }

// Value type
Point p1 = new Point { X = 1, Y = 2 };
Point p2 = p1;       // создаётся копия: p2.X=1, p2.Y=2
p2.X = 10;           // p1.X остаётся 1

// Reference type
Order o1 = new Order { Id = 100 };
Order o2 = o1;       // копируется ссылка
o2.Id = 200;         // теперь и o1.Id == 200
````

## Жизненный цикл и управление памятью

- **Value types** не требуют сборки мусора; их память освобождается при выходе из области видимости (для стека) или при очистке содержащего объекта (для полей в куче).
    
- **Reference types** управляются **GC** (Garbage Collector):
    
    - Объект остаётся в памяти, пока на него есть хотя бы одна живая ссылка.
        
    - По достижении сборки мусора (Gen 0/1/2) неиспользуемые объекты освобождаются.
        

## Размер и выравнивание

- **Value types** могут иметь произвольный размер (от 1 байта до нескольких десятков байт). CLR выравнивает их поля по границам, кратным размеру поля (обычно до 8 байт).
    
- **Reference types** имеют неизменяемую служебную область (объектная шапка, MethodTable) плюс размер полей; выравниваются на границах указателя (4 байта на x86, 8 байт на x64).
    

## Производительность

- Операции с **value types** быстрее при небольших размерах: отсутствие аллокаций в куче и GC‑паузы.
    
- Передача больших структур по значению (например, `struct` > 16 байт) может быть медленной из‑за копирования всего блока. В таких случаях лучше использовать `class` или передавать `ref struct` или `in`/`ref` параметры.
    
- **Boxing**: при приведении value type к `object` или интерфейсу происходит упаковка (allocation на куче) и копирование, что снижает производительность.
    

```csharp
int x = 5;
object o = x;      // boxing: новая упаковка в куче
int y = (int)o;    // unboxing: проверка типа и копирование
```

## Mutability (изменяемость)

- **Value types** по умолчанию являются неизменяемыми (best practice): объявляются с `readonly struct` или без сеттеров, чтобы избежать путаницы при копировании.
    
- **Reference types** часто бывают изменяемыми (mutable), но рекомендуется делать модели данных неизменяемыми, особенно в многопоточных сценариях.
    

## Когда выбирать struct vs class

- Используйте **`struct`** если:
    
    - Тип небольшой (обычно ≤ 16 байт).
        
    - Логически представляет собой одно значение (точка, цвет, ключ).
        
    - Не требует наследования.
        
    - Не хранит поля-ссылки на большие объекты.
        
- Используйте **`class`** если:
    
    - Тип большой или содержит сложные поля/коллекции.
        
    - Требуется полиморфизм и наследование.
        
    - Планируется долгое существование объектов.
        
    - Избежать частых копирований при передаче.
        

## `ref struct`, `readonly struct`, `ref readonly`

- **`ref struct`** (например, `Span<T>`) гарантирует хранение только на стеке, запрещает размещение в куче.
    
- **`readonly struct`** объявляет все поля `readonly` и оптимизируется JIT (может передаваться по ссылке без оборотов безопасных копий).
    
- **`ref readonly`** передаёт ссылку на value type без возможности изменения и без копирования.
    

```csharp
public readonly struct ImmutablePoint
{
    public int X { get; }
    public int Y { get; }
    public ImmutablePoint(int x, int y) { X = x; Y = y; }
}
```

## Представление в методах

- Обычное объявление:
    
    ```csharp
    void Process(Point p) { /* копия p */ }
    ```
    
- С `in` (C# 7.2+): передача по ссылке **для чтения**, без копирования:
    
    ```csharp
    void Process(in Point p) { /* p доступен только для чтения */ }
    ```
    
- С `ref`: передача по ссылке с возможностью модификации оригинала:
    
    ```csharp
    void Modify(ref Point p) { p.X += 10; }
    ```
    

---

Понимание различий между значимыми и ссылочными типами, а также их управлению памятью, выравниванию и передаче — основа эффективной и надёжной разработки на платформе .NET.