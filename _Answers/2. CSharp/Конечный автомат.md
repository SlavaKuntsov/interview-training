Конечный автомат (КA) — абстрактная модель, описывающая систему, которая в любой момент времени находится в одном из конечного числа состояний. Переходы между состояниями происходят в ответ на входные события.

## Определение

Конечный автомат задаётся кортежем (S, Σ, T, s₀, F), где:

- **S** — конечное множество состояний.  
- **Σ** — конечное множество входных символов (алфавит событий).  
- **T**: S × Σ → S — функция переходов.  
- **s₀** ∈ S — начальное состояние.  
- **F** ⊆ S — множество допустимых (финальных) состояний (для распознающих автоматов).

В программировании KA часто используются для моделирования бизнес-процессов, парсинга, управления протоколами, UI-логики и т.п.

## Типы автоматов

1. **Детерминированный конечный автомат (DFA)**  
   Для каждого состояния и символа входного алфавита определён ровно один переход.  

2. **Недетерминированный конечный автомат (NFA)**  
   Для состояния и символа может быть несколько возможных переходов, включая ε‑переходы (пустой символ).

3. **Машина Мура**  
   Выход зависит только от текущего состояния.

4. **Машина Мили**  
   Выход зависит от текущего состояния и входного символа.

## Реализация DFA на C#

Пример: автомат, распознающий строки над алфавитом `{a, b}`, содержащие чётное число `a`.

```csharp
enum State { EvenA, OddA }

class EvenADfa
{
    private State _current = State.EvenA;

    public void Reset() => _current = State.EvenA;

    // Обработка символа
    public void Process(char input)
    {
        switch (_current)
        {
            case State.EvenA:
                _current = (input == 'a') ? State.OddA : State.EvenA;
                break;
            case State.OddA:
                _current = (input == 'a') ? State.EvenA : State.OddA;
                break;
        }
    }

    public bool IsAccepting() => _current == State.EvenA;
}

// Использование
var dfa = new EvenADfa();
string input = "abbaaa";
foreach (char c in input)
    dfa.Process(c);
Console.WriteLine(dfa.IsAccepting()); // False
````

## Общая структура класса автомата

- **Перечисление состояний** `enum State { ... }`.
    
- **Интерпретация входов**: метод `Process(input)` или `Transition(input)`.
    
- **Хранение текущего состояния**: приватное поле `_current`.
    
- **Сброс**: метод `Reset()`.
    
- **Проверка финальности**: `IsAccepting()`.
    

## Реализация с таблицей переходов

Для больших автоматов удобно использовать словарь переходов:

```csharp
class TableDfa<TState, TInput>
    where TState : notnull
    where TInput : notnull
{
    private TState _current;
    private readonly TState _initial;
    private readonly HashSet<TState> _accepting;
    private readonly Dictionary<(TState, TInput), TState> _transitions;

    public TableDfa(
        TState initial,
        IEnumerable<TState> accepting,
        Dictionary<(TState, TInput), TState> transitions)
    {
        _initial = initial;
        _current = initial;
        _accepting = new HashSet<TState>(accepting);
        _transitions = transitions;
    }

    public void Reset() => _current = _initial;

    public void Process(TInput input)
    {
        if (_transitions.TryGetValue((_current, input), out var next))
            _current = next;
        else
            throw new InvalidOperationException($"Недопустимый переход: {_current} + {input}");
    }

    public bool IsAccepting() => _accepting.Contains(_current);
}
```

### Пример использования

```csharp
var transitions = new Dictionary<(State, char), State>
{
    [(State.EvenA, 'a')] = State.OddA,
    [(State.EvenA, 'b')] = State.EvenA,
    [(State.OddA,  'a')] = State.EvenA,
    [(State.OddA,  'b')] = State.OddA,
};

var dfa = new TableDfa<State, char>(
    initial: State.EvenA,
    accepting: new[] { State.EvenA },
    transitions: transitions);

foreach (char c in "abba")
    dfa.Process(c);

Console.WriteLine(dfa.IsAccepting()); // True
```

## Применение конечных автоматов

- **Парсинг**: лексический анализатор (tokenizer) разбивает текст на токены.
    
- **Протоколы**: управление состояниями соединения (TCP, HTTP/2).
    
- **UI**: валидация ввода по шагам (wizard), чёткое управление этапами.
    
- **Игры**: состояния персонажей (стоит, идёт, прыгает, атакует).
    
- **Регулярные выражения**: NFA/DFA для сопоставления шаблонов.
    

## Интеграция с библиотеками

- **Stateless** (NuGet): библиотека для описания автоматов через fluent API, поддерживает асинхронные действия, триггеры переходов, guards:
    
    ```csharp
    var machine = new StateMachine<State, Trigger>(State.Off);
    machine.Configure(State.Off)
           .Permit(Trigger.TurnOn, State.On);
    machine.Configure(State.On)
           .Permit(Trigger.TurnOff, State.Off);
    
    machine.Fire(Trigger.TurnOn);
    ```
    
- **Appccelerate.StateMachine**: расширенная функциональность, диаграммы, persistence.
    

## Советы по проектированию

- Явно определяйте **начальное** и **финальные** состояния.
    
- Обрабатывайте **неожиданные входы** (исключения или переход в “ошибочное” состояние).
    
- Для сложных автоматов применяйте **разбиение** на вложенные или иерархические автоматы (HSM — Hierarchical State Machine).
    
- Документируйте диаграммы состояний (UML Statechart) для прозрачности.
    

---

Конечные автоматы — мощный инструмент для описания детерминированного поведения систем. В .NET их легко реализовать вручную или с помощью специализированных библиотек. 

**Итог**: конечные автоматы делают сложное поведение управляемым, предсказуемым и легко расширяемым, что особенно важно в распределённых, многопоточных и входно‑ориентированных системах на .NET.  

