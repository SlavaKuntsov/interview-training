`stackalloc` — специальный оператор языка C#, позволяющий выделять память **в стеке** вместо управляемой кучи. Это даёт ряд преимуществ по производительности и уменьшению нагрузки на GC, но накладывает ограничения на объём и время жизни данных.

---

### Зачем нужен `stackalloc`

- **Минимизация аллокаций** в куче для временных буферов (например, при парсинге, криптографии, сжатии, форматировании).
- **Уменьшение давления на сборщик мусора**: память автоматически освобождается при выходе из текущей области видимости.
- **Ускорение доступа**: стек быстрее и локальнее, чем куча; меньший объём кэш-промахов.

---

### Синтаксис и базовый пример

```csharp
// До C# 7.2: только для byte*
unsafe
{
    byte* buffer = stackalloc byte[256];
    for (int i = 0; i < 256; i++)
        buffer[i] = 0xFF;
}

// Начиная с C# 7.2: можно использовать Span<T>
Span<int> numbers = stackalloc int[128];
for (int i = 0; i < numbers.Length; i++)
    numbers[i] = i * i;
````

- В **`unsafe`**-коде вы получаете **указатель** (`byte*`, `int*`).
    
- С введением **`Span<T>`** (C# 7.2+) можно безопасно работать с выделенной памятью без небезопасного кода.
    

---

### Ограничения и правила

1. **Размер буфера**
    
    - Обычно ограничен размером стека (по умолчанию ~1 MB в .NET).
        
    - Не стоит выделять большие массивы (`stackalloc byte[100_000_000]` приведёт к StackOverflow).
        
2. **Область видимости и время жизни**
    
    - Память действует **до конца метода** или до конца блока `{ ... }`, в котором объявлен `stackalloc`.
        
    - После выхода из области видимости память **автоматически освобождается**.
        
3. **Только для локальных переменных**
    
    - Нельзя возвращать `Span<T>` напрямую из метода, если он ссылается на `stackalloc`, иначе получите ошибку компиляции — `ByReference to stack memory may not be used`.
        
4. **Только для unmanaged-типа T**
    
    - `T` должен быть **неуправляемым** (`unmanaged` constraint) — примитивы, `struct` без ссылочных полей.
        
    - Пример: `stackalloc MyStruct[10]` допустимо, если `MyStruct` содержит только поля-значения.
        
5. **Только в методах**
    
    - Нельзя использовать `stackalloc` в полях класса, свойствах, лямбдах вне метода без `unsafe`.
        

---

### Примеры использования

#### 1. Парсинг целых чисел из текста

```csharp
public static bool TryParseInts(ReadOnlySpan<char> text, Span<int> output, out int count)
{
    count = 0;
    int i = 0;
    while (i < text.Length)
    {
        // временный буфер для цифр числа (максимум 10 символов для int)
        Span<char> temp = stackalloc char[16];
        int len = 0;
        while (i < text.Length && text[i] != ',')
            temp[len++] = text[i++];
        if (!int.TryParse(temp.Slice(0, len), out int value))
            return false;
        if (count >= output.Length) return false;
        output[count++] = value;
        i++; // пропустить запятую
    }
    return true;
}

// Использование
Span<int> values = stackalloc int[16];
if (TryParseInts("10,20,30", "10,20,30".AsSpan(), values, out int n))
{
    for (int j = 0; j < n; j++) Console.WriteLine(values[j]);
}
```

#### 2. Быстрая инициализация буфера

```csharp
Span<byte> buffer = stackalloc byte[1024];
buffer.Clear();      // заполняет нулями
buffer.Fill(0xFF);   // заполняет 0xFF
```

#### 3. Шифрование / хэширование

```csharp
Span<byte> message = stackalloc byte[64];
// ... заполняем сообщение
Span<byte> hashBuffer = stackalloc byte[32];
SHA256.HashData(message, hashBuffer);
// ... используем hashBuffer
```

---

### Варианты и оптимизации

- **`stackalloc` + `fixed`**  
    В `unsafe`-коде можно зафиксировать указатель на `Span<T>`:
    
    ```csharp
    Span<byte> data = stackalloc byte[128];
    unsafe
    {
        fixed (byte* p = data)
        {
            CryptoTransform(p, data.Length);
        }
    }
    ```
    
- **`stackalloc` в выражениях**  
    Можно сразу передавать в методы:
    
    ```csharp
    ProcessBuffer(stackalloc byte[256]);
    ```
    
- **Много меньших буферов**  
    В горячих путях выгоднее несколько небольших `stackalloc` (<= 512 байт), чем один большой.
    

---

### Потенциальные риски

- **StackOverflowException**  
    При чрезмерном использовании или глубокой рекурсии вместе с `stackalloc` легко превысить стек.
    
- **Неявные аллокации**  
    Если код генерирует `Span<T>` поверх кучи (например, конкатенация строк), возможно неожиданное создание кучи.
    
- **Ошибки времени жизни**  
    Попытка вернуть `Span<T>` ссылающийся на стек — компилятор запрещает, но в `unsafe` коде можно получить дичь.
    

---

### Рекомендации

- Используйте `stackalloc` для **кратковременных** буферов малого размера (до нескольких килобайт).
    
- Предпочитайте `Span<T>` поверх указателей — безопаснее и компактен.
    
- Профилируйте горячие участки кода — убедитесь, что уменьшение аллокаций на куче оправдывает риск работы со стеком.
    
- Не возвращайте `Span<T>` на стек за пределы метода — соблюдайте правила области видимости.
    

---

Оператор `stackalloc` предлагает мощный инструмент для оптимизации производительности и снижения нагрузки на сборщик мусора, когда вам нужны быстрые одноразовые буферы. Грамотное применение `stackalloc` в сочетании с `Span<T>` гарантирует безопасную, эффективную и предсказуемую работу кода.```