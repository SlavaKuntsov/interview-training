### Основные понятия

- **JIT (Just‑In‑Time Compilation)** — механизм динамической компиляции IL-кода в машинный код во время выполнения приложения.  
- **AOT (Ahead‑Of‑Time Compilation)** — статическая компиляция IL-кода в нативный машинный код до запуска приложения, чаще всего во время сборки или установки.

---

### Just‑In‑Time Compilation

#### Порядок работы

1. **Загрузка сборки**  
   CLR загружает сборку в память (AppDomain/CoreCLR context).  
2. **Разбор метаданных и IL**  
   По вызову метода CLR находит в секции metadata определение метода и его IL-тело.  
3. **JIT‑компиляция**  
   - Первый вызов метода → IL проходит через JIT-компилятор.  
   - Генерируется нативный код для текущей платформы (x86/x64/ARM).  
   - Код кешируется в памяти для повторных вызовов.  
4. **Выполнение**  
   CLR передаёт управление нативному коду, возвращает результат.

#### Типы JIT

- **Pre-JIT** (classic .NET Framework)  
  — все методы компилируются заранее при первом старте, долгое время холодного старта.  
- **Econo-JIT**  
  — компиляция «по требованию», без кэширования, освобождает память сразу после исполнения метода.  
- **Normal‑JIT**  
  — сочетает компиляцию по требованию и кэширование нативного кода до выгрузки AppDomain.  
- **Tiered‑JIT** (.NET Core и .NET 5+)  
  1. **Quick JIT** — сначала метод компилируется быстро, с минимумом оптимизаций.  
  2. **Optimized JIT** — «горячие» методы (часто вызываемые) пересобираются с полным набором оптимизаций.

#### Оптимизации JIT

- **Inlining** — встраивание тела небольшого метода прямо в вызывающий, уменьшает накладные расходы на вызов.  
  ```csharp
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public int Sum(int a, int b) => a + b;
```

- **Loop Unrolling** — разворачивание цикла для уменьшения числа итераций и переходов.
    
- **Constant Folding** — вычисление констант во время компиляции (например, `3+5` → `8`).
    
- **Register Allocation** — оптимальное размещение переменных в CPU‑регистрах.
    
- **Dead Code Elimination** — удаление неиспользуемого кода.
    
- **Tail Call Optimization** — оптимизация рекурсивных вызовов с префиксом `tail.` в IL.
    

#### Плюсы и минусы JIT

|Плюсы|Минусы|
|---|---|
|Платформонезависимость одной сборки|Замедление старта (JIT‑задержка)|
|Адаптация к конкретному CPU и среде|Ограничения по размеру и времени компиляции|
|Tiered‑JIT повышает производительность на горячих методах|Нестабильная производительность в «холодном» старте|

---

### Ahead‑Of‑Time Compilation

#### Средства AOT в .NET

1. **NGen (Native Image Generator)**
    
    - .NET Framework tool, генерирует нативные образы (.ni.dll/.ni.exe) при установке или администрировании.
        
    - Ускоряет старт, но образы зависят от версии ОС и профиля процессора.
        
2. **ReadyToRun (R2R) / CrossGen & CrossGen2**
    
    - .NET Core/.NET 5+ toolchain: создаёт R2R-образы, частично скомпилированные, оставляя «фрагменты» IL для JIT-оптимизаций.
        
    - Снижение времени старта без потери гибкости полной JIT-платформы.
        
3. **Native AOT (CoreRT, .NET Native)**
    
    - Полная компиляция всего приложения в единый исполняемый файл.
        
    - Минимум зависимостей, мгновенный старт, уменьшенный размер дистрибутива.
        
    - Требует ограничения рефлексии и динамической загрузки кода (необходимо описывать через атрибуты или конфиги).
        

#### Порядок работы AOT

1. **Сборка проекта**
    
    - Компилятор C# → IL-код + метаданные.
        
2. **AOT‑компиляция**
    
    - Специальный инструмент (NGen, CrossGen2, CoreRT) преобразует IL → нативный код.
        
    - Генерирует скомпонованный образ (DLL/EXE) или группу модулей.
        
3. **Установка / Деплой**
    
    - Пользователь получает нативные образы без необходимости иметь CLR/JIT.
        
4. **Запуск**
    
    - Операционная система загружает готовый машинный код сразу в память, минуя JIT.
        

#### Плюсы и минусы AOT

|Плюсы|Минусы|
|---|---|
|Молниеносный старт (нет JIT‑задержки)|Больший размер «cold» бинарников|
|Отсутствие зависимости от CLR‑JIT среды на машине|Ограниченная поддержка рефлексии и генерации кода|
|Предсказуемая производительность «с первого запуска»|Затраты времени при сборке и сложности генерации|
|Безопасность: нет возможности внедрить нежелательный IL|Платформозависимые бинарники, необходимость перекомпиляции под каждую архитектуру|

---

### Когда выбирать JIT vs AOT

|Сценарий|Рекомендация|
|---|---|
|Веб‑ и облачные сервисы, где важна скорость старта|ReadyToRun / Tiered‑JIT|
|Приложения с долгим «жизненным циклом»|Tiered‑JIT + R2R|
|Desktop‑приложения с ограниченным временем старта|Native AOT|
|Устройства IoT с ограниченными ресурсами|Native AOT / CoreRT|
|Пакеты NuGet / библиотеки|Чистый IL + JIT|

---

### Практические советы и примеры

1. **Используйте Tiered‑JIT по умолчанию**
    
    ```xml
    <PropertyGroup>
      <TieredCompilation>true</TieredCompilation>
      <TieredPGO>true</TieredPGO>
    </PropertyGroup>
    ```
    
2. **Генерация ReadyToRun-образов**
    
    ```bash
    dotnet publish -c Release -r win-x64 /p:PublishReadyToRun=true
    ```
    
3. **Native AOT с .NET 7+**
    
    ```xml
    <PropertyGroup>
      <PublishAot>true</PublishAot>
    </PropertyGroup>
    ```
    
    ```bash
    dotnet publish -c Release -r linux-x64
    ```
    
4. **Минимизация рефлексии**
    
    - Используйте `[DynamicDependency]` и `rd.xml` для Native AOT.
        
    - Генерируйте JSON‑конфиги для trimmer’а в PublishAot сценариях.
        

---

### Заключение

Понимание и грамотное использование JIT и AOT-компиляции позволяют:

- Добиться оптимального времени старта.
    
- Максимизировать производительность горячих путей.
    
- Сократить размер дистрибутива и зависимости.
    
- Выбирать подходящий режим для разных типов приложений и окружений.