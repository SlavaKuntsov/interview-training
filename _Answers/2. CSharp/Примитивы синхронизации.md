 #### Какие есть?
- Lock (Monitor)
- Semaphore
- Mutex
- ManualResetEvent
- AutoResetEvent
    ```
    Если коротко, то да. Самое важное отличие заключается в том, что AutoResetEvent позволяет продолжить работу только одному ожидающему потоку. С другой стороны, ManualResetEvent позволяет продолжать работу нескольким потокам одновременно, пока вы не скажете ему остановиться (перезапустить).
    ```

---

# Примитивы синхронизации в .NET

В .NET доступны разнообразные механизмы синхронизации для управления доступом нескольких потоков к общим ресурсам и координации их работы. Выбор подходящего примитива зависит от сценария: критических секций, ожидания сигналов, разделения ресурсов или сложных барьеров.

---

## lock / Monitor

- `lock(obj)` — проще всего использоватьый механизм для критических секций.
- Под капотом использует `Monitor.Enter(obj)` и `Monitor.Exit(obj)`.
- **Особенности**:
  - Блокировка перетекает на один объект-замок.
  - Гарантирован выход из блока даже при исключении.
- **Пример**:
  ```csharp
  private readonly object _sync = new object();

  void Increment()
  {
      lock(_sync)
      {
          // критическая секция
          _counter++;
      }
  }
```

- **Дополнительно**:
    
    - `Monitor.TryEnter(obj, timeout)` — попытка получить блокировку с таймаутом.
        
    - `Monitor.Wait(obj)` / `Monitor.Pulse(obj)` / `Monitor.PulseAll(obj)` — реализация механизма ожидания/уведомления внутри блока `lock`.
        

---

## Mutex

- Системный примитив, может синхронизировать потоки в разных процессах (named mutex).
    
- Тяжёлее `lock`, использует ядро ОС.
    
- Методы:
    
    - `mutex.WaitOne()` — ожидание захвата.
        
    - `mutex.ReleaseMutex()` — освобождение.
        
- **Пример**:
    
    ```csharp
    using(var mutex = new Mutex(false, "Global\\MyAppMutex"))
    {
        if (!mutex.WaitOne(1000))
            throw new TimeoutException("Не удалось получить mutex");
        try
        {
            // работа под защитой mutex
        }
        finally
        {
            mutex.ReleaseMutex();
        }
    }
    ```
    

---

## Semaphore и SemaphoreSlim

### SemaphoreSlim

- Лёгкий, асинхронно совместимый (поддерживает `WaitAsync()`).
    
- Имеет счётчик «разрешений», ограничивает число одновременно вошедших потоков.
    
- Методы:
    
    - `Wait()` / `WaitAsync()` — захват одного разрешения.
        
    - `Release()` — освобождение разрешения.
        

```csharp
private readonly SemaphoreSlim _sem = new SemaphoreSlim(3);

async Task ProcessAsync()
{
    await _sem.WaitAsync();
    try
    {
        // не более 3 параллельных задач внутри
    }
    finally
    {
        _sem.Release();
    }
}
```

### Semaphore

- Кросспроцессный вариант, работает через ядро ОС.
    
- `WaitOne()`, `Release()`.
    

---

## ReaderWriterLockSlim

- Позволяет множественные потоки читать одновременно, но эксклюзивно блокирует на запись.
    
- Методы:
    
    - `EnterReadLock()` / `ExitReadLock()`
        
    - `EnterWriteLock()` / `ExitWriteLock()`
        
    - `EnterUpgradeableReadLock()` / `ExitUpgradeableReadLock()`
        
- **Пример**:
    
    ```csharp
    private readonly ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();
    
    void Read()
    {
        _rw.EnterReadLock();
        try { /* чтение */ }
        finally { _rw.ExitReadLock(); }
    }
    
    void Write()
    {
        _rw.EnterWriteLock();
        try { /* запись */ }
        finally { _rw.ExitWriteLock(); }
    }
    ```
    

---

## AutoResetEvent и ManualResetEventSlim

### AutoResetEvent

- Сигнальный примитив: один ждущий поток разблокируется при вызове `Set()`, затем сбрасывается автоматически.
    
- `WaitOne()` — ждать сигнал.
    
- `Set()` — передать сигнал одному потоку.
    
- `Reset()` — вручную сбросить сигнал (обычно не нужно).
    

### ManualResetEventSlim

- Оптимизированная версия, внутри использует спинлок и событие ОС.
    
- `Set()` — переводит в сигнальное состояние до явного `Reset()`.
    
- `Reset()` — сброс сигнала.
    
- `Wait()` / `Wait(timeout)` — ожидание.
    

```csharp
var evt = new ManualResetEventSlim(false);

// Thread A
evt.Wait(); // ждёт, пока не вызовут Set()

// Thread B
evt.Set();  // разблокирует все ожидающие потоки
```

---

## CountdownEvent

- Сигнализирует, когда счётчик достигает нуля.
    
- Инициализируется значением `initialCount`.
    
- `Signal()` — уменьшает счётчик на 1.
    
- `Wait()` — ожидает, пока счётчик не станет 0.
    
- `Reset(int count)` — сбрасывает счётчик.
    

```csharp
var cde = new CountdownEvent(5);
for(int i=0; i<5; i++)
    Task.Run(() => {
        DoWork();
        cde.Signal();
    });
cde.Wait(); // дождаться окончания всех 5 задач
```

---

## Barrier

- Координирует группы потоков на барьере: все участники ждут друг друга на каждом шаге.
    
- Инициализируется числом участников.
    
- `SignalAndWait()` — сигнал и ожидание остальных.
    
- Поддерживает динамическое добавление/уборку участников.
    

```csharp
var barrier = new Barrier(participantCount: 3);
for(int i=0; i<3; i++)
    Task.Run(() => {
        Phase1();
        barrier.SignalAndWait();
        Phase2();
        barrier.SignalAndWait();
    });
// Все потоки завершат Phase1 прежде, чем продолжат Phase2.
```

---

## SpinLock и SpinWait

### SpinLock

- Неблокирующий примитив, при захвате ждёт в цикле (spin) вместо перехода в ожидание ОС.
    
- Уместен для очень кратких критических секций.
    
- Требует аккуратного использования, легко привести к «проглатыванию» CPU.
    

```csharp
var spin = new SpinLock();
bool lockTaken = false;
try
{
    spin.Enter(ref lockTaken);
    // критическая секция
}
finally
{
    if (lockTaken) spin.Exit();
}
```

### SpinWait

- Помогает реализовывать поллинговые ожидания с оптимизациями (Yield, переключение потока).
    

---

## ManualLock-Free Примитивы

- **Interlocked** (`Interlocked.Increment`, `CompareExchange`, `Exchange`) — атомарные операции над примитивными типами без блокировок.
    
- Применять для простых счётчиков, ссылок, флагов.
    

```csharp
int counter = 0;
Interlocked.Increment(ref counter);
```

---

Правильный выбор примитива синхронизации позволяет обеспечить безопасность доступа, минимизировать время простоя и оптимально использовать ресурсы процессора и памяти.