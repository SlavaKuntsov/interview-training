Boxing и Unboxing — механизмы преобразования значимых (value) типов в ссылочные (reference) и обратно. Понимание этих процессов важно для оптимизации производительности и избежания ненужных аллокаций в куче.

## Boxing

При Boxing значимый тип упаковывается в объект в управляемой куче:

1. Выделяется память под новый объект в Small Object Heap (SOH).
2. Значение value-типа копируется в эту область памяти.
3. Возвращается ссылка типа `object` или интерфейса, который реализует исходный тип.

```csharp
int x = 123;          // x хранится на стеке
object obj = x;       // Boxing: создаётся объект в SOH, копируется значение 123
````

### Когда происходит Boxing

- Присвоение значимого типа переменной `object` или интерфейсу:
    
    ```csharp
    struct Point { public int X, Y; }
    Point p = new Point { X = 1, Y = 2 };
    object o = p;    // Boxing
    ```
    
- Передача значимого типа в метод, принимающий `object`:
    
    ```csharp
    void Foo(object o) { /*...*/ }
    Foo(10);       // Boxing int → object
    ```
    
- Использование негeneric-коллекций (`ArrayList`, `Hashtable`):
    
    ```csharp
    ArrayList list = new ArrayList();
    list.Add(5);   // Boxing int → object
    ```
    

## Unboxing

При Unboxing объект преобразуется обратно в значение value-типа:

1. CLR проверяет, что объект действительно является упакованным значимым типом нужного типа.
    
2. Копирует значение из объекта в новый или существующий value-type на стеке.
    
3. Возвращает скопированное значение.
    

```csharp
object obj = 123;     // Boxing
int y = (int)obj;     // Unboxing: проверка типа и копирование
```

### Важные детали

- Unboxing **всегда** требует явного приведения (cast). Неправильный cast вызовет `InvalidCastException`.
    
- После Unboxing получается **копия** значения. Изменение копии не влияет на исходный объект в куче:
    
    ```csharp
    object o = 5;
    int a = (int)o;
    a = 10;
    // o всё ещё содержит 5 в куче
    ```
    

## Затраты и влияние на производительность

- **Boxing** вызывает аллокацию в куче и создаёт давление на сборщик мусора.
    
- **Unboxing** включает в себя проверку типа и копирование данных.
    
- Частый Boxing/Unboxing может значительно снизить производительность и увеличить задержки GC.
    

## Как избежать Boxing/Unboxing

- Использовать **дженерики** (`List<T>`, `Dictionary<TKey, TValue>`) вместо негeneric-коллекций:
    
    ```csharp
    List<int> list = new List<int>();
    list.Add(5);    // Без Boxing
    ```
    
- Применять **обобщённые методы** и **методы расширения**:
    
    ```csharp
    void Foo<T>(T value) { /* ... */ }
    Foo(10);  // Нет Boxing
    ```
    
- Использовать **`Span<T>`** и **`Memory<T>`** для работы с буферами без аллокаций.
    

## Boxing `Nullable<T>`

При Boxing `Nullable<T>`:

- Если `HasValue == true`, происходит Boxing внутреннего значения `T`.
    
- Если `HasValue == false`, результат Boxing — `null`.
    

```csharp
int? ni = 5;
object o1 = ni;   // Boxing int → object (значение 5)
int? nj = null;
object o2 = nj;   // o2 == null
```

## Итог

Boxing и Unboxing — фундаментальные механизмы CLR, влияющие на распределение памяти и производительность. Избегайте ненужных упаковок, используя дженерики и современные конструкции `Span<T>`/`Memory<T>`, чтобы создавать более эффективные и отзывчивые .NET-приложения. ```