Исключения — механизм обработки ошибок в .NET, который позволяет «пробрасывать» сигнал об ошибке и перехватывать его в более высокоуровневом коде. Понимание того, как правильно генерировать и переиспользовать исключения, а также разница между `throw` и `throw ex`, критически важно для отладки и сохранения корректного стека вызовов.

## Общее о исключениях

- Все исключения в .NET наследуются от базового класса `System.Exception`.  
- В рамках обработки ошибок принято:
  1. **Генерировать** исключение в точке возникновения ошибки.  
  2. **Не перехватывать** его немедленно, если невозможно корректно восстановиться.  
  3. **Поймать** в месте, где можно исправить ситуацию или провести логирование и информировать пользователя.  

```csharp
public void ProcessFile(string path)
{
    if (!File.Exists(path))
        throw new FileNotFoundException($"Файл не найден: {path}", path);

    // дальнейшая обработка
}
````

## Конструкция `throw`

Простое использование `throw` внутри блока `catch` повторно пробрасывает текущее исключение **без изменения** информации о стеке:

```csharp
try
{
    // код, способный бросить исключение
}
catch (Exception)
{
    // логирование, очистка ресурсов...
    throw;  // пробросить то же исключение
}
```

- **Сохраняется оригинальный стек вызовов** (stack trace), что позволяет точно локализовать место возникновения ошибки.
    
- Идеально подходит, если вам нужно выполнить какую‑то логику в блоке `catch` (например, лог) и затем передать исключение дальше.
    

## Конструкция `throw ex`

Использование `throw ex` внутри `catch (Exception ex)` создаёт **новый** вызов `throw`, ассоциированный с переменной `ex`:

```csharp
try
{
    // код...
}
catch (Exception ex)
{
    // логирование...
    throw ex;  // бросает копию исключения
}
```

- При этом **перезаписывается** стек вызовов: верхняя часть (до `throw ex`) заменяется текущей точкой генерации.
    
- В результате теряется информация о первоначальной точке возникновения ошибки, что затрудняет диагностику.
    

## Сравнение `throw` vs `throw ex`

| Характеристика                  | `throw`    | `throw ex`                  |
| ------------------------------- | ---------- | --------------------------- |
| Сохранение оригинального стека  | Да         | Нет                         |
| Трассировка места возникновения | Корректная | Показывает место `throw ex` |
| Подходит для логирования        | Да         | Нет                         |
| Антипаттерн                     | —          | Да                          |

## Рекомендации и лучшие практики

1. **Всегда** используйте `throw;` внутри `catch`, если хотите пробросить перехваченное исключение.
    
2. **Не** используйте `throw ex;` — это сломает стек и затруднит отладку.
    
3. Если нужно изменить тип исключения или добавить контекст, создайте **новое** исключение, передав исходное в параметр `InnerException`:
    
    ```csharp
    catch (SqlException sqlEx)
    {
        throw new DataAccessException("Ошибка при сохранении данных", sqlEx);
    }
    ```
    
4. **Логируйте** исключения сразу в точке их перехвата, но без разрушения стека.
    
5. Используйте **специфичные** для ситуации типы исключений (не `Exception`, а, например, `InvalidOperationException`, `ArgumentNullException` и т. д.).
    
6. Не игнорируйте исключения: пустые блоки `catch { }` — признак проблем (сопрятанная ошибка).
    

## Пример правильной обработки

```csharp
public void ImportData(string filePath)
{
    try
    {
        var data = File.ReadAllText(filePath);
        ParseAndSave(data);
    }
    catch (FileNotFoundException fnf)
    {
        Log.Warn(fnf, "Не удалось найти файл для импорта");
        throw;  // сохраняем стек
    }
    catch (IOException ioEx)
    {
        Log.Error(ioEx, "Ошибка ввода-вывода при чтении файла");
        throw new ImportException("Не удалось считать файл импорта", ioEx);
    }
}
```

- В первом `catch` используем `throw;` для сохранения исходной трассировки.
    
- Во втором создаём новое исключение `ImportException`, оборачивая исходное в `InnerException`.
    

---

Понимание и соблюдение этих правил обеспечит корректную диагностику ошибок и упростит сопровождение вашего .NET‑кода.