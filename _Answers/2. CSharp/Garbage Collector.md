Сборщик мусора (GC) — ключевой компонент CLR, отвечающий за автоматическое управление памятью. Он освобождает неиспользуемую память, упрощая разработку, но требует понимания внутренних механизмов для оптимизации производительности.

## Модели GC и версии

- **Workstation GC**  
  - По умолчанию в десктопных приложениях.  
  - Поддерживает однопоточную (для UI‑приложений) и многопоточную версии.  
  - **Concurrent GC** (до .NET 4.5) выполняет сборку Gen 0/1 параллельно с работой приложений, снижая паузы.

- **Server GC**  
  - По умолчанию в ASP.NET Core и серверных службах.  
  - Для каждого логического процессора создаётся отдельный heap и поток GC, что увеличивает пропускную способность и эффективно использует многопроцессорность.  
  - Всегда многопоточный.

- **Background GC** (начиная с .NET 4.5)  
  - Заменила Concurrent GC.  
  - Позволяет собирать Gen 2 одновременно с обработкой Gen 0/1 в фоне, снижая остановку мира (“stop‑the‑world”).

### Выбор режима

В `.runtimeconfig.json` или в `<App.config>`:
```xml
<configuration>
  <runtime>
    <gcServer enabled="true"/>       <!-- server GC -->
    <gcConcurrent enabled="false"/>  <!-- фоновые сборки отключены -->
  </runtime>
</configuration>
````

## Поколения и организцация heap

- **Gen 0** — краткоживущие объекты, очищается часто.
    
- **Gen 1** — “буфер” между короткоживущими и долгоживущими, очищается реже.
    
- **Gen 2** — долгоживущие объекты, очищается при сильных запросах.
    
- **Large Object Heap (LOH)** — объекты ≥ 85 000 байт, очищается только при полной сборке Gen 2.
    
- **Pinned Object Heap (POH)** (в .NET 5+) — объекты, закреплённые в памяти.
    

При каждом GC CLR идёт снизу вверх: сначала Gen 0, затем при необходимости Gen 1, потом Gen 2.

## Сборка и компактизация

1. **Mark**: помечает все достижимые объекты, начиная от корней (статические поля, стеки потоков).
    
2. **Sweep**: освобождает память не помеченных объектов.
    
3. **Compact**: (по умолчанию) перемещает выжившие объекты к началу heap, чтобы избежать фрагментации.
    
    - LOH не компактизируется (до .NET 5); после .NET 5 можно включить компактизацию LOH вручную.
        
4. **Relocate Pointers**: обновляет все ссылки на перемещённые объекты.
    

### Фрагментация

- **SOH**: компактизация поддерживает высокую плотность, фрагментация минимальна.
    
- **LOH**: не компактизируется по умолчанию, со временем фрагментируется — медленная аллокация больших массивов.
    
- **POH**: выделяется отдельно, не влияет на SOH/LOH, не компактизируется.
    

### Управление LOH-фрагментацией

- В .NET 5+:
    
    ```csharp
    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
    GC.Collect();  // выполнит полную GC с компактизацией LOH один раз
    ```
    
- Использовать `ArrayPool<T>` для переиспользования больших буферов.
    
- Минимизировать частое создание/удаление больших объектов.
    

## Генерации и частота сборок

- **Gen 0 GC** запускается автоматически при нехватке памяти в Gen 0 (обычная ситуация).
    
- **Gen 1 GC** запускается, когда объекты выживают одну или несколько сборок Gen 0.
    
- **Gen 2 GC** запускается при давлении памяти на Gen 2 или LOH, или вручную через `GC.Collect(2)`.
    
- Полная сборка (`GC.Collect()` без параметров) — Gen 2 + LOH (+ POH если указано).
    

## Настройка и API

- `GC.Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting)` — полный контроль.
    
- `GC.WaitForPendingFinalizers()` — ждать завершения финализаторов.
    
- `GC.GetTotalMemory(bool forceFullCollection)` — текущее потребление памяти.
    
- `GCSettings.LatencyMode` — режим задержек:
    
    - `Interactive` (default)
        
    - `LowLatency` (минимизировать паузы для краткоживущих операций)
        
    - `SustainedLowLatency` (поддерживать низкую задержку, минимизируя фоновые GC)
        

```csharp
GCSettings.LatencyMode = GCLatencyMode.LowLatency;
try
{
    // критический код с минимальными паузами
}
finally
{
    GCSettings.LatencyMode = GCLatencyMode.Interactive;
}
```

## Диагностика и профилирование

- **dotnet-counters**: мониторинг счётчиков GC (`% Time in GC`, `Gen 0/1/2 Collections`).
    
- **dotnet-trace** и **PerfView**: сбор трейсинговых данных, анализ задержек и фрагментации LOH.
    
- **Visual Studio Diagnostic Tools** (Memory Usage): снимки heap, распределение по поколениям, LOH-блоки.
    
- **EventCounters** и **ETW**: глубокая телеметрия GC.
    

## Взаимодействие с финализаторами

- Объекты с финализаторами (`~Class()`) помещаются в финализаторную очередь и очищаются в отдельном цикле, что может задержать освобождение памяти.
    
- Рекомендуется реализовывать `IDisposable` и освобождать ресурсы детерминировано, избегая ненужных финализаций.
    

## Советы по оптимизации

- Минимизируйте аллокации в горячих участках кода (циклах, парсинге).
    
- Используйте структуры (`struct`) для небольших данных, если они не вызывают нежелательного копирования.
    
- Применяйте `Span<T>` и `Memory<T>` для работы с временными буферами.
    
- Переиспользуйте большие объекты через пулы (`ArrayPool<T>`).
    
- Контролируйте `GCSettings.LatencyMode` в критических сценариях с высокой нагрузкой.
    
- Стройте нагрузочные тесты, чтобы оценить поведение GC при реальных объёмах данных.
    

---

_Данный материал основан на внутренней архитектуре CLR, официальной документации Microsoft и многолетнем опыте оптимизации .NET‑приложений._```