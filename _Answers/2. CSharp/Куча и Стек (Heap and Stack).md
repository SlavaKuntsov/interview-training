## Память процесса

- **Stack** выделяется каждому потоку при старте (по умолчанию ~1 МБ). Используется по схеме LIFO: параметры методов, локальные переменные значимых типов и ссылки на объекты.  
- **Managed Heap** — глобальная область памяти, управляемая CLR. Хранит все экземпляры ссылочных типов и упакованные значимые типы.  
- **Small Object Heap (SOH)** — сегмент для объектов меньшего размера (до ~85 000 байт).  
- **Large Object Heap (LOH)** — сегмент для объектов ≥ 85 000 байт.  
- **Pinned Object Heap (POH)** (начиная с .NET 5) — сегмент для pinned-объектов, которые нельзя перемещать.

## Что кладётся в стек

```csharp
void Foo()
{
    int a = 5;           // value-type → стек
    var p = new Point(); // struct, но создан через 'new' → экземпляр в куче, ссылка в стеке
    Bar(a, p);
}
````

- `a` хранится непосредственно в стеке текущего потока.
    
- При вызове `Bar` параметры копируются в новый stack frame.
    

## Что кладётся в кучу

```csharp
class Order { public int Id; public decimal Price; }
var o = new Order(); // экземпляр Order → куча, ссылка на o в стеке
```

- Любой `class` создаётся через `new` в куче.
    
- Значимый тип (`struct`), созданный через `new`, также размещается в куче.
    

## Жизненный цикл объекта в куче

1. **Allocation**: CLR быстро увеличивает указатель свободной памяти (bump-pointer).
    
2. **Promotion**: выжившие после сборки сборки объекты переходят в Gen 1, потом в Gen 2.
    
3. **Collection**: GC периодически останавливает мир (stop-the-world), помечает недостижимые объекты и освобождает память.
    

### Поколения

- **Gen 0** — новые объекты, собирается часто.
    
- **Gen 1** — промежуточное поколение.
    
- **Gen 2** — долгоживущие объекты, собирается реже при давлении памяти.
    
- **LOH** — объекты ≥ 85 000 байт, собирается только при полной сборке Gen 2.
    
- **POH** — pinned-объекты, не компактизируется, собирается при полной сборке Gen 2.
    

## Взаимодействие значимых и ссылочных типов

|Операция|Где хранится (Stack)|Где хранится (Heap)|
|---|---|---|
|`int x = 42;`|значение|—|
|`object o = x;`|ссылка|boxing: копия `x` в куче|
|`Point p = new();`|ссылка|экземпляр `Point` в куче (хоть это struct)|

## Производительность

- Доступ к стеку быстрее: отсутствует GC, данные кэш‑локальны.
    
- Аллокация в куче быстрая, но GC может вызвать паузы.
    
- Частое создание/удаление мелких объектов → давление на Gen 0.
    
- Большие массивы → давление на LOH.
    

## Фрагментация кучи (Heap Fragmentation)

**Фрагментация** возникает, когда свободные блоки памяти разбросаны, что затрудняет выделение больших непрерывных областей.

- **SOH** практически не фрагментируется благодаря компактизации на каждом сборе Gen 0/1.
    
- **LOH** не компактизируется по умолчанию (до .NET 5) и со временем фрагментируется, что ведёт к неудачным аллокациям и задержкам при полной сборке.
    
- **POH** изолирован, но сам не компактизируется, так как объекты закреплены.
    

### Методы борьбы с фрагментацией

1. **Компактизация LOH** (.NET 5+):
    
    ```csharp
    GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
    GC.Collect(); // выполнит полную сборку и компактизацию LOH один раз
    ```
    
2. **Пулинг больших буферов** через `ArrayPool<T>.Shared`.
    
3. **Минимизация краткоживущих больших объектов** — предпочитайте постоянное переиспользование.
    
4. **Разбиение больших объектов** на меньшие, чтобы они попадали в SOH.
    
5. **Мониторинг** фрагментации с помощью PerfView или Visual Studio.
    

## Оптимизации

- Использовать `Span<T>` и `stackalloc` для краткоживущих буферов:
    
    ```csharp
    Span<int> buffer = stackalloc int[128];
    ```
    
- Избегать ненужного boxing — применять дженерики.
    
- Кэшировать неизменяемые объекты (паттерн Flyweight).
    
- Структуры до 16 байт держать как `struct` без `new`.
    

## Tail Call и Stack Overflow

- Глубокая рекурсия может исчерпать стек и привести к `StackOverflowException`.
    
- Хвостовая рекурсия иногда оптимизируется JIT (в Release), но не гарантирована.
    

## Параллелизм и изоляция

- Каждый поток имеет свой стек, но общую кучу (синхронизированную внутри GC).
    
- Для хранения данных, связанных с потоком или async‑контекстом, использовать `ThreadStatic` и `AsyncLocal<T>`.
    

## Диагностика и инструменты

- **dotnet-counters**, **dotnet-dump**, **PerfView** — анализ аллокаций и поколений GC.
    
- В Visual Studio: **Diagnostic Tools → Memory Usage** — снимки heap, распределение по поколениям.
    
- **dotnet-gcdump**, **dotnet-trace** — детализированный сбор данных о GC.
    

## Практические советы

- Контролировать аллокации в горячих циклах (избегайте `new` в цикле).
    
- Переиспользовать большие буферы через пулы (`ArrayPool<T>`).
    
- Не хранить большие коллекции в статических полях без реальной необходимости.
    
- Для высокочастотных структурных данных использовать `ref struct` или `readonly struct`.
    
- Анализировать поведение GC при нагрузке, чтобы своевременно выявлять проблемы.
    

---

_Материал основан на механизмах CLR, официальной документации Microsoft и многолетнем опыте оптимизации .NET приложений._