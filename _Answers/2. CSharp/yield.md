
`yield` упрощает реализацию итераторов — методов, возвращающих последовательности элементов без необходимости вручную создавать класс-генератор `IEnumerator<T>`. Компилятор автоматически генерирует машину состояний.

---

### `yield return`

- Используется внутри метода, возвращающего `IEnumerable<T>` или `IEnumerator<T>`.  
- Каждый `yield return <expr>` отдаёт следующий элемент последовательности, pause-ит выполнение метода до следующего запроса элемента.

```csharp
public IEnumerable<int> GetEvenNumbers(int max)
{
    for (int i = 0; i <= max; i += 2)
    {
        yield return i; // возвращаем текущее значение и замораживаем состояние
    }
}
````

**При использовании**

```csharp
foreach (var n in GetEvenNumbers(10))
    Console.WriteLine(n);
```

— элементы вычисляются и выдаются «лениво», по одному, по требованию.

---

### `yield break`

- Прекращает итерацию досрочно, эквивалентно завершению метода.
    

```csharp
public IEnumerable<string> GetLines(string[] lines)
{
    foreach (var line in lines)
    {
        if (string.IsNullOrEmpty(line))
            yield break;  // больше не возвращаем ничего
        yield return line;
    }
}
```

---

### Внутреннее устройство

При компиляции метода с `yield` создаётся скрытый класс-генератор:

1. **Поля машины состояний**: текущее состояние, локальные переменные метода.
    
2. **Метод `MoveNext()`**: выполняет тело итератора до следующего `yield return`/`yield break`.
    
3. **Свойство `Current`**: возвращает значение последнего `yield return`.
    
4. **Метод `Reset()`** и `Dispose()` по умолчанию.
    

Это позволяет:

- Избавиться от шаблонного кода создания `IEnumerator<T>`.
    
- Автоматически поддерживать **ленивую** генерацию элементов.
    
- Поддерживать **несколько одновременных** перечислений (каждое создаёт свой экземпляр машины).
    

---

### Преимущества

- **Простота**: меньше кода, нет ручного контроля состояния.
    
- **Лень**: элементы генерируются только при необходимости.
    
- **Память**: не нужно заранее хранить весь список — элементы создаются на лету.
    

---

### Ограничения и «ловушки»

- **Не подходит** для потокобезопасности: каждый `IEnumerable<T>` создаёт новую машину, но сам метод не синхронизирован.
    
- **Нельзя** использовать `yield` внутри `try…catch`, где `catch` ловит исключения, или внутри `unsafe`-блока с указателями.
    
- **Ускорение/оптимизация**: код с `yield` не инлайнируется, более медленный, чем простой массив/список.
    
- **Невозможно** вернуть асинхронный итератор до C# 8; в .NET Core 3+/C# 8+ появляются `async IAsyncEnumerable<T>` и `await foreach`.
    

---

### Асинхронные итераторы (C# 8+)

```csharp
public async IAsyncEnumerable<int> GetDataAsync()
{
    for (int i = 0; i < 5; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}

// Использование
await foreach (var x in GetDataAsync())
    Console.WriteLine(x);
```

- Комбинирует `async/await` и `yield return` для ленивой выдачи элементов из асинхронных источников.
    
- Возвращает `IAsyncEnumerable<T>`, потребляется через `await foreach`.
    

---

### Практические сценарии

- Генерация бесконечных или «дорогих» последовательностей (файловые стримы, результаты запроса к БД).
    
- Постраничная выдача данных (pagination), когда нужно возвращать по N элементов за раз.
    
- Рекурсивные обходы (деревья, графы) без ручного стека:
    
    ```csharp
    public IEnumerable<Node> Traverse(Node root)
    {
        yield return root;
        foreach (var child in root.Children)
            foreach (var desc in Traverse(child))
                yield return desc;
    }
    ```
    

---

`yield` — мощный синтаксический сахар в C#, позволяющий компактно и наглядно писать итераторы, сохраняя при этом ленивую генерацию и структурированное управление потоком выполнения.