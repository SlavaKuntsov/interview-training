### Смысл ключевых слов

- **`override`** — используется для **переопределения** виртуального (или абстрактного) метода базового класса. Гарантирует полиморфное поведение: метод потомка вызывается через ссылку на базовый тип.

- **`new`** — используется для **скрытия** (hiding) метода базового класса, создающего в производном классе свою версию метода с такой же сигнатурой. При вызове через переменную базового типа будет использоваться базовый метод.

---

### Сценарий: базовый и производный классы

```csharp
public class Animal
{
    public void Speak()
    {
        Console.WriteLine("Animal speaks (non-virtual)");
    }

    public virtual void Eat()
    {
        Console.WriteLine("Animal eats (virtual)");
    }
}

public class Dog : Animal
{
    // Скрытие метода Speak базового класса
    public new void Speak()
    {
        Console.WriteLine("Dog barks (new)");
    }

    // Переопределение метода Eat базового класса
    public override void Eat()
    {
        Console.WriteLine("Dog eats (override)");
    }
}
````

---

### Поведение при разных способах вызова

```csharp
var dog = new Dog();
dog.Speak();   // Dog barks (new)
dog.Eat();     // Dog eats (override)

Animal animalRef = dog;
animalRef.Speak(); // Animal speaks (non-virtual) — скрытый метод не виден через базовый
animalRef.Eat();   // Dog eats (override)      — переопределенный метод вызывается через базовый
```

- При **`new`**:
    
    - Компилятор создаёт отдельный метод в потомке, **скрывающий** метод базового класса.
        
    - Вызов через ссылку типа `Dog` — вызов дочернего.
        
    - Вызов через ссылку типа `Animal` — вызов базового.
        
- При **`override`**:
    
    - Потомок **замещает** реализацию базового метода.
        
    - Вызов всегда идёт по **динамической типизации** (виртуальный вызов), вне зависимости от того, какая ссылка используется.
        

---

### Особенности и рекомендации

1. **Требования к `override`:**
    
    - Метод базового класса **должен** быть объявлен как `virtual`, `abstract` или `override`.
        
    - Сигнатура метода потомка должна совпадать с базовым (включая модификаторы доступа).
        
2. **Требования к `new`:**
    
    - Базовый метод **не обязательно** должен быть виртуальным.
        
    - При опущенном `new` компилятор выдаст предупреждение («method hides inherited member… use new keyword»), но скомпилирует код, скрытие всё равно произойдёт.
        
3. **Полиморфизм vs скрытие:**
    
    - Используйте `override`, когда хотите **полиморфное** поведение.
        
    - Используйте `new` только в исключительных случаях, когда необходимо предоставить альтернативную реализацию, но не ломать контракты базового класса.
        
4. **Читаемость кода:**
    
    - `override` подчёркивает намерение переопределить поведение базового метода.
        
    - `new` сигнализирует о **скрытии** и требует внимательного чтения — легче допустить ошибки в логике.
        
5. **Вызов базовой реализации:**
    
    - В методе с `override` или в скрывающем (`new`) можно обратиться к оригиналу:
        
        ```csharp
        public override void Eat()
        {
            base.Eat(); // вызвать Animal.Eat
            Console.WriteLine("Dog eats with appetite");
        }
        
        public new void Speak()
        {
            Console.WriteLine("Dog barks loudly");
            base.Speak(); // вызвать Animal.Speak
        }
        ```
        
6. **Интерфейсы и явная реализация:**
    
    - При реализации интерфейса нет `override`/`new` — все методы интерфейсов автоматически виртуальные.
        
    - Можно явно реализовать метод интерфейса, скрыв его от прямого вызова через класс:
        
        ```csharp
        public class Cat : IAnimal
        {
            void IAnimal.Speak() { /*...*/ } // доступен только через IAnimal
            public void Speak() { /*...*/ }   // обычный метод класса
        }
        ```
        

---

### Итоги

- **`override`** — для классического **замещения** виртуального метода и обеспечения полиморфизма.
    
- **`new`** — для **скрытия** метода базового класса без изменения его виртуальности; метод потомка «молча» не влияет на вызовы через базовый тип.
    

Правильное использование этих ключевых слов обеспечивает прозрачность и предсказуемость поведения наследования в C#. 